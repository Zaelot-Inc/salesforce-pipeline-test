name: Validate release PR against Production (check-only)

on:
  pull_request:
    branches: [ main ]
    types: [ opened, reopened, synchronize, ready_for_review ]
    # this filter already helps, but we also add a runtime guard below

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: 'prod-validate-pr-${{ github.event.pull_request.number }}'
  cancel-in-progress: true

jobs:
  prod-validate:
    name: Prod validate-only (origin/main -> PR head)
    runs-on: ubuntu-latest
    env:
      SF_LOGIN_URL_PROD: "https://test.salesforce.com"

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # NEW: detect whether the PR actually touches force-app/**
      - name: Detect force-app changes
        id: touched
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: number, per_page: 100 });
            const hasForceApp = files.some(f => f.filename.startsWith('force-app/'));
            core.setOutput('has_force_app', hasForceApp ? 'true' : 'false');

      # If NO force-app changes, succeed and stop
      - name:  no force-app changes (success)
        if: steps.touched.outputs.has_force_app != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: "ℹ️ Skipping Production validation: this PR does not touch `force-app/**`."
            });
            // success by default (no failure)

      - name: Install requirements (sf CLI, sfdx-git-delta, jq)
        if: steps.touched.outputs.has_force_app == 'true'
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true

      - name: Ensure Java 11+
        if: steps.touched.outputs.has_force_app == 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'zulu'

      - name: Prepare refs (origin/main)
        if: steps.touched.outputs.has_force_app == 'true'
        run: |
          set -euo pipefail
          git fetch --no-tags origin main:refs/remotes/origin/main
          git rev-parse --verify origin/main
          echo "HEAD of PR: ${{ github.event.pull_request.head.sha }}"

      - name: Generate delta (origin/main -> PR head)
        id: delta
        run: |
          set -euo pipefail
          TO_SHA="${{ github.event.pull_request.head.sha }}"
          echo "Generating delta: origin/main -> ${TO_SHA}"
          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to   "${TO_SHA}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          has_addmods="false"
          has_deletions="false"

          if [ -d changed-sources/force-app ] && [ -n "$(ls -A changed-sources/force-app || true)" ]; then
            has_addmods="true"
          fi
          if [ -f "changed-sources/destructiveChanges/destructiveChanges.xml" ] || \
            [ -f "changed-sources/destructiveChangesPost/destructiveChanges.xml" ]; then
            has_deletions="true"
          fi

          echo "has_addmods=$has_addmods"     >> "$GITHUB_OUTPUT"
          echo "has_deletions=$has_deletions" >> "$GITHUB_OUTPUT"


      - name: Early exit if no metadata changes
        id: early
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.has_addmods != 'true' && steps.delta.outputs.has_deletions != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner, repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const body = "ℹ️ No deployable metadata differences detected between `main` and this PR — skipping Production validation.";
            await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
            core.setOutput('skip_process', 'true');
     
      - name: Write Prod JWT key
        if: steps.outputs.skip_process != 'true'
        env:
          SF_JWT_KEY_PROD: ${{ secrets.SF_JWT_KEY }}
        run: |
          set -euo pipefail
          [ -z "${SF_JWT_KEY_PROD:-}" ] && { echo "SF_JWT_KEY_PROD missing"; exit 1; }
          umask 177
          printf "%s" "$SF_JWT_KEY_PROD" > jwt_prod.key
      - name: Sanity check JWT env
        env:
          SF_JWT_CLIENT_PROD: ${{ secrets.SF_JWT_CLIENT }}
          SF_JWT_USERNAME_PROD: ${{ secrets.SF_JWT_USERNAME }}
        run: |
          echo "Endpoint: ${SF_LOGIN_URL_PROD}"
          echo "Client ID length: ${#SF_JWT_CLIENT_PROD}"
          echo "Username: ${#SF_JWT_USERNAME_PROD}"
          openssl rsa -in jwt_prod.key -check -noout >/dev/null && echo "Private key OK" || (echo "Bad private key"; exit 1)
          
      - name: Login to Production (JWT)
        if: steps.outputs.skip_process != 'true'
        env:
          SF_JWT_CLIENT_PROD: ${{ secrets.SF_JWT_CLIENT }}
          SF_JWT_USERNAME_PROD: ${{ secrets.SF_JWT_USERNAME }}
        run: |
          set -euo pipefail
          sf org login jwt \
            --username "$SF_JWT_USERNAME_PROD" \
            --client-id "$SF_JWT_CLIENT_PROD" \
            --jwt-key-file jwt_prod.key \
            --instance-url "${SF_LOGIN_URL_PROD}" \
            --alias ProdForValidation --set-default --json

      - name: Validate deployment to Production (Quick Deploy–ready) and persist JSON + ID
        id: prod_validate
        shell: bash
        if: steps.outputs.skip_process != 'true'
        run: |
          set -euo pipefail

          # Ensure a manifest exists (needed especially for destructive-only changes)
          if [ ! -f "changed-sources/package/package.xml" ]; then
            mkdir -p changed-sources/package
            API_VER=$(jq -r '.sourceApiVersion // .packageDirectories[0].versionName // empty' sfdx-project.json || echo "")
            API_VER=${API_VER:-60.0}
            printf '%s\n' \
              '<?xml version="1.0" encoding="UTF-8"?>' \
              '<Package xmlns="http://soap.sforce.com/2006/04/metadata">' \
              "  <version>${API_VER}</version>" \
              '</Package>' > changed-sources/package/package.xml

          fi

          # Build flags: validate full set (adds/mods + optional destructive)
          flags=( 
            --target-org ProdForValidation 
            --test-level RunLocalTests 
            --wait 120 
            --json 
            --manifest "changed-sources/package/package.xml" 
          )

          # If sfdx-git-delta produced destructive manifests, include them in the same validation
          if [ -f "changed-sources/destructiveChanges/destructiveChanges.xml" ]; then
            flags+=( --pre-destructive-changes "changed-sources/destructiveChanges/destructiveChanges.xml" )
          fi
          if [ -f "changed-sources/destructiveChangesPost/destructiveChanges.xml" ]; then
            flags+=( --post-destructive-changes "changed-sources/destructiveChangesPost/destructiveChanges.xml" )
          fi

          # Run the Quick-Deployable validation
          sf project deploy validate "${flags[@]}" > prod-validate.json

          # Capture useful outputs for later steps
          VALIDATE_ID=$(jq -r '.id // .result.id // empty' prod-validate.json)
          echo "validate_id=${VALIDATE_ID}" >> "$GITHUB_OUTPUT"
          echo "${VALIDATE_ID:-}" > prod-validate-id.txt || true

          status=$(jq -r '.status // .result.status // "unknown"' prod-validate.json || echo "unknown")
          failures=$(jq '.result.details.runTestResult.failures | length // 0' prod-validate.json || echo 0)
          echo "status=$status" >> "$GITHUB_OUTPUT"
          echo "failures=$failures" >> "$GITHUB_OUTPUT"
      - name: Upload prod validation JSON artifacts
        if: steps.outputs.skip_process != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: prod-validate-pr-${{ github.event.pull_request.number }}
          path: |
            prod-validate.json
            prod-validate-id.txt


      - name: Comment results on the PR and fail on test errors
        if: steps.outputs.skip_process != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner, repo = context.repo.repo;
            const number = context.payload.pull_request.number;

            const file = 'prod-validate.json';
            const idPath = 'prod-validate-id.txt';
            let body = "### Production validation result (Quick Deploy–ready)\n\n";

            let validateId = '';
            if (fs.existsSync(idPath)) {
              validateId = fs.readFileSync(idPath, 'utf8').trim();
            }

            let failures = [];
            let deployStatus = 'unknown';
            if (fs.existsSync(file)) {
              try {
                const data = JSON.parse(fs.readFileSync(file,'utf8'));
                failures = (((data || {}).result || {}).details || {}).runTestResult?.failures || [];
                deployStatus = data?.status || (data?.result?.status) || 'unknown';
              } catch (e) {
                body += `Could not parse prod-validate.json: ${e.message}\n\n`;
              }
            } else {
              body += "No prod-validate.json produced; check workflow logs.\n\n";
            }

            body += `Status: **${deployStatus}**\n\n`;
            if (validateId) {
              body += `**Validation ID:** \`${validateId}\`\n\n`;
              body += `You can Quick Deploy later with:\n\n`;
              body += "```bash\n";
              body += `sf project deploy quick --target-org ProdForValidation --job-id ${validateId} --wait 120 --json\n`;
              body += "```\n\n";
            }

            if (failures.length) {
              body += `Found **${failures.length}** failing Apex test(s):\n\n| Class | Method | Message |\n|---|---|---|\n`;
              for (const f of failures.slice(0,30)) {
                const msg = String(f.message || '').replace(/\n/g, ' ').slice(0,500);
                body += `| ${f.name} | ${f.methodName} | ${msg} |\n`;
              }
              body += `\n(Full validation JSON uploaded as artifact.)\n`;
            } else {
              body += "No Apex test failures found.\n";
            }

            await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
            if (failures.length) core.setFailed(`Prod validation reported ${failures.length} Apex failures.`);
