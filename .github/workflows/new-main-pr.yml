name: Generate deploy manifests + PR instructions (no auto validation)
on:
  pull_request:
    branches: [ main ]
    types: [ opened, reopened, synchronize, ready_for_review ]
  workflow_call:
    inputs:
      ref:
        description: "Release branch / SHA to validate"
        required: true
        type: string
      pr_number:
        description: "Origin PR number (for comments)"
        required: false
        type: string
      pr_title:
        description: "Origin PR title (for messages)"
        required: false
        type: string

permissions:
  contents: write          # we commit manifests into the PR branch (same-repo PRs)
  pull-requests: write

concurrency:
  group: main-pr-manifests-${{ github.event.pull_request.number || inputs.pr_number || inputs.ref || github.sha }}
  cancel-in-progress: true
env:
  IS_WF_CALL: ${{ inputs.ref != '' || inputs.pr_number != '' }}

jobs:
  build-manifests-and-comment:
    name: Build delta manifests + PR comment
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ inputs.ref || github.sha }}


    # If invoked via workflow_call, synthesize PR context for downstream steps
      - name: Set PR context (workflow_call)
        if: ${{ env.IS_WF_CALL }}
        shell: bash
        run: |
          echo "PR_NUM=${{ inputs.pr_number || '0' }}" >> $GITHUB_ENV
          echo "PR_TITLE=${{ inputs.pr_title || 'Release validation (workflow_call)' }}" >> $GITHUB_ENV
          echo "PR_HEAD_REF=${{ inputs.ref }}" >> $GITHUB_ENV
          echo "PR_HEAD_SHA=${{ inputs.ref }}" >> $GITHUB_ENV

      - name: Set PR context (pull_request)
        if: ${{ !env.IS_WF_CALL }}
        shell: bash
        run: |
          echo "PR_NUM=${{ github.event.pull_request.number || '0' }}" >> $GITHUB_ENV
          echo "PR_TITLE=${{ github.event.pull_request.title || 'Release validation (pull_request)' }}" >> $GITHUB_ENV
          echo "PR_HEAD_REF=${{ github.event.pull_request.head.ref }}" >> $GITHUB_ENV
          echo "PR_HEAD_SHA=${{ github.event.pull_request.head.sha }}" >> $GITHUB_ENV

      # Quick guard: does the PR touch force-app at all?
      - name: Detect force-app changes
        id: touched
        shell: bash  
        run: |
            set -euo pipefail
            FROM=origin/main
            TO="${{ env.PR_HEAD_REF }}"
            if git diff --name-only --diff-filter=ACDMR "$FROM" "$TO" -- 'force-app/**' | grep -q .; then
              echo "has_force_app=true" >> "$GITHUB_OUTPUT"
            else
              echo "has_force_app=false" >> "$GITHUB_OUTPUT"
            fi

      # If NO force-app changes at all, exit gracefully
      - name: No force-app changes (success)
        if: steps.touched.outputs.has_force_app != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const raw = process.env.PR_NUM || "";
            const prNumber = parseInt(raw, 10);
            if (!Number.isInteger(prNumber) || prNumber <= 0) {
              core.info(`PR_NUM is invalid ("${raw}"); skipping comment.`);
              return;
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.PR_NUM),
              body: "ℹ️ Skipping manifest generation: this PR does not touch `force-app/**`."
            });

      - name: Install requirements (sf CLI, sfdx-git-delta, jq)
        if: steps.touched.outputs.has_force_app == 'true'
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true

      - name: Ensure Java 11 (needed by some plugins)
        if: steps.touched.outputs.has_force_app == 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'zulu'

      # Prefer the "PR merge" ref (what will land); fallback to PR head if merge ref isn't available.
      - name: Prepare refs (origin/main + target)
        id: refs
        shell: bash
        env:
          GH_REPO:  ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          IS_WF_CALL: ${{ inputs.ref != '' || inputs.pr_number != '' }}
          INPUT_REF: ${{ inputs.ref }}
          INPUT_PR:  ${{ inputs.pr_number }}
          PR_NUM:    ${{ github.event.pull_request.number || inputs.pr_number || '' }}
        run: |
          set -euo pipefail

          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GH_REPO}.git"
          git fetch --no-tags origin +refs/heads/main:refs/remotes/origin/main
          git rev-parse --verify refs/remotes/origin/main >/dev/null

          to_ref=""

          if [ "${IS_WF_CALL}" = "true" ]; then
            # Reusable workflow path: resolve INPUT_REF (branch name or SHA)
            REF="${INPUT_REF}"

            if [ -z "${REF}" ]; then
              echo "::error::inputs.ref is empty for workflow_call"; exit 1
            fi

            # Try to fetch as a branch first
            if git ls-remote --exit-code --heads origin "refs/heads/${REF}" >/dev/null 2>&1; then
              git fetch --no-tags origin "refs/heads/${REF}:refs/remotes/target/${REF}"
              to_ref="refs/remotes/target/${REF}"
              echo "Using target ref as branch: ${to_ref}"
            # Try PR head (if REF looks like a PR number)
            elif [[ "${REF}" =~ ^[0-9]+$ ]] && git ls-remote --exit-code origin "refs/pull/${REF}/head" >/dev/null 2>&1; then
              git fetch --no-tags origin "refs/pull/${REF}/head:refs/remotes/target/pr-${REF}-head"
              to_ref="refs/remotes/target/pr-${REF}-head"
              echo "Using target ref as PR head: ${to_ref}"
            # Try as a commit SHA
            elif [[ "${REF}" =~ ^[0-9a-fA-F]{7,40}$ ]]; then
              # Ensure the SHA exists locally
              if ! git cat-file -e "${REF}^{commit}" 2>/dev/null; then
                # Fetch the SHA by mirroring all refs (shallow); harmless and quick
                git fetch --no-tags --depth=50 origin "+${REF}:${REF}" || true
              fi
              to_ref="${REF}"
              echo "Using target ref as commit: ${to_ref}"
            else
              echo "::error::Could not resolve inputs.ref='${REF}' as branch, PR number, or commit SHA"
              exit 1
            fi

          else
            # PR trigger path: fetch PR merge ref, fallback to head
            PR="${PR_NUM}"

            if ! [[ "${PR}" =~ ^[0-9]+$ ]]; then
              echo "::error::PR number is empty/invalid in PR path ('${PR}')"; exit 1
            fi

            if git fetch --no-tags origin "refs/pull/${PR}/merge:refs/remotes/origin/pr-${PR}-merge" 2>/dev/null; then
              to_ref="refs/remotes/origin/pr-${PR}-merge"
              echo "Using PR merge ref: ${to_ref}"
            else
              git fetch --no-tags origin "refs/pull/${PR}/head:refs/remotes/origin/pr-${PR}-head"
              to_ref="refs/remotes/origin/pr-${PR}-head"
              echo "Using PR head ref: ${to_ref}"
            fi
          fi

          echo "to_ref=${to_ref}" >> "$GITHUB_OUTPUT"


      - name: Generate delta (origin/main -> $TO_REF)
        if: steps.touched.outputs.has_force_app == 'true'
        id: delta
        shell: bash
        run: |
          set -euo pipefail # This 'set -e' is the source of the problem
          rm -rf changed-sources
          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to   "${TO_REF}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          has_addmods="false"
          has_deletions="false"
          
          [ -d changed-sources/force-app ] && [ -n "$(ls -A changed-sources/force-app || true)" ] && has_addmods="true"
          
          echo "Checking for destructive changes..."

          if [ -f changed-sources/destructiveChanges/destructiveChanges.xml ]; then
            echo "Found destructiveChanges.xml, checking for <members>..."
            if grep -q "<members>" changed-sources/destructiveChanges/destructiveChanges.xml; then
              echo "Found <members> in destructiveChanges.xml."
              has_deletions="true"
            else
              echo "File is empty or contains no <members>."
            fi
          fi
          
          if [ -f changed-sources/destructiveChangesPost/destructiveChanges.xml ]; then
            echo "Found destructiveChangesPost.xml, checking for <members>..."
            if grep -q "<members>" changed-sources/destructiveChangesPost/destructiveChanges.xml; then
              echo "Found <members> in destructiveChangesPost.xml."
              has_deletions="true"
            else
              echo "File is empty or contains no <members>."
            fi
          fi

          echo "has_addmods=${has_addmods}"     >> "$GITHUB_OUTPUT"
          echo "has_deletions=${has_deletions}" >> "$GITHUB_OUTPUT"

          if [ "${has_addmods}" != "true" ] && [ "${has_deletions}" != "true" ]; then
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
          else
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Early exit if no metadata changes
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const number = Number(process.env.PR_NUM);
            await github.rest.issues.createComment({
              owner, repo, issue_number: number,
              body: "ℹ️ No delta found between `main` and this PR — no manifests generated."
            });

          
      - name: Build branch-safe name + output paths
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        id: naming
        shell: bash
        run: |
          set -euo pipefail
          RAW="${{ github.event.pull_request.head.ref }}"
          SAFE="$(printf "%s" "$RAW" | sed -E 's/[^A-Za-z0-9._-]+/-/g')"
          PKG="manifest/branch/${SAFE}-package.xml"
          DEST="manifest/branch/${SAFE}-package-destructive.xml"
          echo "branch_raw=${RAW}"  >> "$GITHUB_OUTPUT"
          echo "branch_safe=${SAFE}" >> "$GITHUB_OUTPUT"
          echo "pkg_path=${PKG}"     >> "$GITHUB_OUTPUT"
          echo "dest_path=${DEST}"   >> "$GITHUB_OUTPUT"

      - name: Create manifest/branch/<branch>-package.xml (adds/mods)
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${{ steps.naming.outputs.pkg_path }}")"
          if [ -f "changed-sources/package/package.xml" ]; then
            cp "changed-sources/package/package.xml" "${{ steps.naming.outputs.pkg_path }}"
          else
            # deletion-only changes -> synthesize a minimal, valid package.xml
            API_VER="$(jq -r '.sourceApiVersion // empty' sfdx-project.json 2>/dev/null || true)"
            API_VER="${API_VER:-64.0}"
            
            echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
            <Package xmlns=\"http://soap.sforce.com/2006/04/metadata\">
              <version>${API_VER}</version>
            </Package>" > "${{ steps.naming.outputs.pkg_path }}"
          fi

      - name: Create manifest/branch/<branch>-package-destructive.xml (if deletions)
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.has_deletions == 'true'
        shell: bash
        env:
          # This correctly passes the variable TO the Python script
          DEST_PATH: ${{ steps.naming.outputs.dest_path }}
        run: |
          set -euo pipefail
          
          # This is a debug step, "checking the obvious"
          echo "DEST_PATH is set to: ${DEST_PATH}"
          
          # Now, execute the Python script
          python3 .github/scripts/merge_destructive.py
      - name: Can we push to this PR branch?
        id: canpush
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber =
              Number(process.env.PR_NUM || context.payload?.pull_request?.number || 0);

            if (!prNumber) {
              core.info('No PR number available; cannot determine push permissions.');
              core.setOutput('same_repo', 'false');
              core.setOutput('head_ref', '');
              core.setOutput('head_owner', '');
              core.setOutput('head_repo', '');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner, repo, pull_number: prNumber
            });

            const headRepoFull = (pr.head?.repo?.full_name || '').toLowerCase();
            const sameRepo = headRepoFull === `${owner}/${repo}`.toLowerCase();

      - name: Commit manifests into the PR branch
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true' && steps.canpush.outputs.same_repo == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config user.name  "github-actions[bot]"
          git add -A -- "manifest/branch"
          if git diff --cached --quiet; then
            echo "Manifests unchanged; nothing to commit."
            exit 0
          fi
          git commit -m "chore(manifest): generate delta manifests for PR #:${{ env.PR_NUM }}"
          git push origin "HEAD:${ process.env.PR_HEAD_REF }"

      - name: Upload manifests as artifact (fork PRs / no push)
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true' && steps.canpush.outputs.same_repo != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: pr-${{ github.event.pull_request.number }}-manifests
          path: |
            ${{ steps.naming.outputs.pkg_path }}
            ${{ steps.naming.outputs.dest_path }}
          if-no-files-found: ignore

      - name: Comment instructions on the PR
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const number = Number(process.env.PR_NUM);

            // Get all your variables from previous steps
            const branch = "${{ steps.naming.outputs.branch_safe }}";
            const pkg = "${{ steps.naming.outputs.pkg_path }}";
            const dest = "${{ steps.naming.outputs.dest_path }}";
            const hasDel = "${{ steps.delta.outputs.has_deletions }}" === "true";
            const canPush = "${{ steps.canpush.outputs.same_repo }}" === "true";

            // Read the template file from the repository
            let body = fs.readFileSync('.github/templates/how-to-deploy-prod.md', 'utf8');

            // --- Helper function to remove conditional blocks ---
            const removeBlock = (tag, content) => {
              const regex = new RegExp(`<!-- ${tag} -->[\\s\\S]*?<!-- END${tag} -->`, 'g');
              return content.replace(regex, '');
            };
            
            // --- 1. Handle Conditional Blocks ---
            if (hasDel) {
              // Deletions exist: remove the "no destructive" block and the "destructive" line
              body = removeBlock('IF_NO_DESTRUCTIVE', body);
            } else {
              // No deletions: remove the "destructive" blocks
              body = removeBlock('IF_DESTRUCTIVE', body);
            }
            

            if (canPush) {
              // It's a same-repo PR, so remove the "fork" message
              body = removeBlock('IF_FORK_PR', body);
            }
            
            // Clean up any remaining conditional tags (the ones we decided to keep)
            body = body.replace(/<!-- \/?IF_.*? -->/g, '');

            // --- 2. Replace Placeholders ---
            body = body.replace(/{{BRANCH_SAFE}}/g, branch);
            body = body.replace(/{{PKG_PATH}}/g, pkg);
            body = body.replace(/{{DEST_PATH}}/g, dest);

            // --- 3. Post the Comment ---
            await github.rest.issues.createComment({ owner, repo, issue_number: number, body });