name: Validate release PR against Production (check-only)

on:
  pull_request:
    branches: [ main ]
    types: [ opened, reopened, synchronize, ready_for_review ]
    # this filter already helps, but we also add a runtime guard below

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: 'prod-validate-pr-${{ github.event.pull_request.number }}'
  cancel-in-progress: true

jobs:
  prod-validate:
    name: Prod validate-only (origin/main -> PR head)
    runs-on: ubuntu-latest
    env:
      SF_LOGIN_URL_PROD: "https://test.salesforce.com"

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # NEW: detect whether the PR actually touches force-app/**
      - name: Detect force-app changes
        id: touched
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: number, per_page: 100 });
            const hasForceApp = files.some(f => f.filename.startsWith('force-app/'));
            core.setOutput('has_force_app', hasForceApp ? 'true' : 'false');

      # If NO force-app changes, succeed and stop
      - name:  no force-app changes (success)
        if: steps.touched.outputs.has_force_app != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: "ℹ️ Skipping Production validation: this PR does not touch `force-app/**`."
            });
            // success by default (no failure)

      - name: Install requirements (sf CLI, sfdx-git-delta, jq)
        if: steps.touched.outputs.has_force_app == 'true'
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true

      - name: Ensure Java 11+
        if: steps.touched.outputs.has_force_app == 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'zulu'

      - name: Prepare refs (origin/main + PR merge, with fallback to head)
        shell: bash
        env:
          PR_NUM: ${{ github.event.pull_request.number }}
          GH_REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GH_REPO}.git"

          # Base
          git fetch --no-tags origin main:refs/remotes/origin/main
          git rev-parse --verify refs/remotes/origin/main

          # Try MERGE ref (what will land)
          if git fetch --no-tags origin "refs/pull/${PR_NUM}/merge:refs/remotes/origin/pr-${PR_NUM}-merge"; then
            echo "TO_REF=refs/remotes/origin/pr-${PR_NUM}-merge" >> "$GITHUB_ENV"
            echo "Using PR merge ref."
          else
            echo "PR merge ref not available (likely conflicts). Falling back to PR head."
            git fetch --no-tags origin "refs/pull/${PR_NUM}/head:refs/remotes/origin/pr-${PR_NUM}-head"
            git rev-parse --verify "refs/remotes/origin/pr-${PR_NUM}-head"
            echo "TO_REF=refs/remotes/origin/pr-${PR_NUM}-head" >> "$GITHUB_ENV"
          fi

          echo "Base SHA: $(git rev-parse --short refs/remotes/origin/main)"
          echo "To   SHA: $(git rev-parse --short $(sed -n 's/^TO_REF=//p' "$GITHUB_ENV"))"


      - name: Generate delta (origin/main -> $TO_REF)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf changed-sources
          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to   "${TO_REF}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          if [ -d changed-sources/force-app ] && [ -n "$(ls -A changed-sources/force-app || true)" ]; then
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Early exit if no metadata changes
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner, repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const body = "ℹ️ No deployable metadata differences detected between `main` and this PR — skipping Production validation.";
            await github.rest.issues.createComment({ owner, repo, issue_number: number, body });

      - name: Write Prod JWT key
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        env:
          SF_JWT_KEY_PROD: ${{ secrets.SF_JWT_KEY }}
        run: |
          set -euo pipefail
          [ -z "${SF_JWT_KEY_PROD:-}" ] && { echo "SF_JWT_KEY_PROD missing"; exit 1; }
          umask 177
          printf "%s" "$SF_JWT_KEY_PROD" > jwt_prod.key

      - name: Login to Production (JWT)
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        env:
          SF_JWT_CLIENT_PROD: ${{ secrets.SF_JWT_CLIENT }}
          SF_JWT_USERNAME_PROD: ${{ secrets.SF_JWT_USERNAME }}
        run: |
          set -euo pipefail
          sf org login jwt \
            --username "$SF_JWT_USERNAME_PROD" \
            --client-id "$SF_JWT_CLIENT_PROD" \
            --jwt-key-file jwt_prod.key \
            --instance-url "${SF_LOGIN_URL_PROD}" \
            --alias ProdForValidation --set-default --json

      - name: Validate-only deploy to Production (check-only) and persist JSON
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        run: |
          set -euo pipefail
          PROD_VALIDATION_FILE=prod-validate.json
          sf project deploy start \
            --source-dir "changed-sources/force-app" \
            --target-org ProdForValidation \
            --dry-run \
            --test-level RunLocalTests \
            --wait 120 \
            --json > "${PROD_VALIDATION_FILE}"

          if [ -s "${PROD_VALIDATION_FILE}" ] && jq -e . >/dev/null 2>&1 < "${PROD_VALIDATION_FILE}"; then
            status=$(jq -r '.status // .result.status // "unknown"' "${PROD_VALIDATION_FILE}" || echo "unknown")
            failures=$(jq '.result.details.runTestResult.failures | length // 0' "${PROD_VALIDATION_FILE}" || echo 0)
            echo "Validation status: ${status}; failures: ${failures}"
          else
            echo "prod-validate.json missing/invalid"; exit 1
          fi

      - name: Upload prod validation JSON artifact
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: prod-validate-json-pr-${{ github.event.pull_request.number }}
          path: prod-validate.json

      - name: Comment results on the PR and fail on test errors
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner, repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const file = 'prod-validate.json';

            let body = "### Production validation result\n\n";
            if (fs.existsSync(file)) {
              try {
                const data = JSON.parse(fs.readFileSync(file,'utf8'));
                const failures = (((data || {}).result || {}).details || {}).runTestResult?.failures || [];
                const deployStatus = data?.status || (data?.result?.status) || 'unknown';
                body += `Status: **${deployStatus}**\n\n`;
                if (failures.length) {
                  body += `Found **${failures.length}** failing Apex test(s):\n\n| Class | Method | Message |\n|---|---|---|\n`;
                  for (const f of failures.slice(0,30)) {
                    const msg = String(f.message || '').replace(/\n/g, ' ').slice(0,500);
                    body += `| ${f.name} | ${f.methodName} | ${msg} |\n`;
                  }
                  body += `\n(Full validation JSON uploaded as artifact)\n`;
                } else {
                  body += "No Apex test failures found.\n";
                }
                await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
                if (failures.length) {
                  core.setFailed(`Prod validation reported ${failures.length} Apex failures.`);
                }
              } catch (e) {
                await github.rest.issues.createComment({
                  owner, repo, issue_number: number,
                  body: `Could not parse prod-validate.json: ${e.message}`
                });
                core.setFailed('Invalid validation JSON.');
              }
            } else {
              await github.rest.issues.createComment({
                owner, repo, issue_number: number,
                body: "No prod-validate.json produced; check workflow logs."
              });
              core.setFailed('No validation JSON produced.');
            }
