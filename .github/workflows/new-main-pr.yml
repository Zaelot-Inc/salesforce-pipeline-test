name: Validate release PR against Production (check-only)

on:
  pull_request:
    branches: [ main ]
    types: [ opened, reopened, synchronize, ready_for_review ]
    # this filter already helps, but we also add a runtime guard below

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: 'prod-validate-pr-${{ github.event.pull_request.number }}'
  cancel-in-progress: true

jobs:
  prod-validate:
    name: Prod validate-only (origin/main -> PR head)
    runs-on: ubuntu-latest
    env:
      SF_LOGIN_URL_PROD: "https://test.salesforce.com"

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # NEW: detect whether the PR actually touches force-app/**
      - name: Detect force-app changes
        id: touched
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: number, per_page: 100 });
            const hasForceApp = files.some(f => f.filename.startsWith('force-app/'));
            core.setOutput('has_force_app', hasForceApp ? 'true' : 'false');

      # If NO force-app changes, succeed and stop
      - name:  no force-app changes (success)
        if: steps.touched.outputs.has_force_app != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: "ℹ️ Skipping Production validation: this PR does not touch `force-app/**`."
            });
            // success by default (no failure)

      - name: Install requirements (sf CLI, sfdx-git-delta, jq)
        if: steps.touched.outputs.has_force_app == 'true'
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true

      - name: Ensure Java 11+
        if: steps.touched.outputs.has_force_app == 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'zulu'

      - name: Prepare refs (origin/main)
        if: steps.touched.outputs.has_force_app == 'true'
        run: |
          set -euo pipefail
          git fetch --no-tags origin main:refs/remotes/origin/main
          git rev-parse --verify origin/main
          echo "HEAD of PR: ${{ github.event.pull_request.head.sha }}"

      - name: Generate delta (origin/main -> PR head)
        id: delta
        run: |
          set -euo pipefail
          TO_SHA="${{ github.event.pull_request.head.sha }}"
          echo "Generating delta: origin/main -> ${TO_SHA}"
          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to   "${TO_SHA}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          has_addmods="false"
          has_deletions="false"

          if [ -d changed-sources/force-app ] && [ -n "$(ls -A changed-sources/force-app || true)" ]; then
            has_addmods="true"
          fi
          if [ -f "changed-sources/destructiveChanges/destructiveChanges.xml" ] || \
            [ -f "changed-sources/destructiveChangesPost/destructiveChanges.xml" ]; then
            has_deletions="true"
          fi

          echo "has_addmods=$has_addmods"     >> "$GITHUB_OUTPUT"
          echo "has_deletions=$has_deletions" >> "$GITHUB_OUTPUT"


      - name: Early exit if no metadata changes
        id: early
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.has_addmods != 'true' && steps.delta.outputs.has_deletions != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner, repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const body = "ℹ️ No deployable metadata differences detected between `main` and this PR — skipping Production validation.";
            await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
            core.setOutput('skip_process', 'true');
     
      - name: Write Prod JWT key
        if: steps.outputs.skip_process != 'true'
        env:
          SF_JWT_KEY_PROD: ${{ secrets.SF_JWT_KEY }}
        run: |
          set -euo pipefail
          [ -z "${SF_JWT_KEY_PROD:-}" ] && { echo "SF_JWT_KEY_PROD missing"; exit 1; }
          umask 177
          printf "%s" "$SF_JWT_KEY_PROD" > jwt_prod.key
      - name: Sanity check JWT env
        env:
          SF_JWT_CLIENT_PROD: ${{ secrets.SF_JWT_CLIENT }}
          SF_JWT_USERNAME_PROD: ${{ secrets.SF_JWT_USERNAME }}
        run: |
          echo "Endpoint: ${SF_LOGIN_URL_PROD}"
          echo "Client ID length: ${#SF_JWT_CLIENT_PROD}"
          echo "Username: ${#SF_JWT_USERNAME_PROD}"
          openssl rsa -in jwt_prod.key -check -noout >/dev/null && echo "Private key OK" || (echo "Bad private key"; exit 1)
          
      - name: Login to Production (JWT)
        if: steps.outputs.skip_process != 'true'
        env:
          SF_JWT_CLIENT_PROD: ${{ secrets.SF_JWT_CLIENT }}
          SF_JWT_USERNAME_PROD: ${{ secrets.SF_JWT_USERNAME }}
        run: |
          set -euo pipefail
          sf org login jwt \
            --username "$SF_JWT_USERNAME_PROD" \
            --client-id "$SF_JWT_CLIENT_PROD" \
            --jwt-key-file jwt_prod.key \
            --instance-url "${SF_LOGIN_URL_PROD}" \
            --alias ProdForValidation --set-default --json

      - name: Validate deployment to Production (Quick Deploy–ready) and persist JSON + ID
        id: prod_validate
        if: steps.outputs.skip_process != 'true'
        # make sure this step uses bash
        shell: bash
        run: |
          # Safe, traceable bash
          set -Eeuo pipefail
          export TZ=UTC
          PS4='+ [${BASH_SOURCE##*/}:${LINENO}] '
          set -x
          trap 'rc=$?; echo "::error::Failed at ${BASH_SOURCE##*/}:${LINENO} running: ${BASH_COMMAND} (exit $rc)"; exit $rc' ERR

          echo "::group::Preflight"
          echo "PWD=$(pwd)"
          command -v sf && sf --version || true
          command -v jq && jq --version || true
          ls -R changed-sources || echo "No changed-sources dir yet"
          echo "::endgroup::"

          # Ensure a manifest exists (needed especially for destructive-only changes)
          if [ ! -f "changed-sources/package/package.xml" ]; then
            mkdir -p "changed-sources/package"
            API_VER="$(jq -r '.sourceApiVersion // .packageDirectories[0].versionNumber // empty' sfdx-project.json 2>/dev/null || true)"
            API_VER="${API_VER:-60.0}"
            printf '%s\n' \
              '<?xml version="1.0" encoding="UTF-8"?>' \
              '<Package xmlns="http://soap.sforce.com/2006/04/metadata">' \
              "  <version>${API_VER}</version>" \
              '</Package>' > "changed-sources/package/package.xml"
            echo "Created changed-sources/package/package.xml (API ${API_VER})"
          else
            echo "Using existing changed-sources/package/package.xml"
          fi

          # Build flags: validate full set (adds/mods + optional destructive)
          flags=(
            --target-org ProdForValidation
            --test-level RunLocalTests
            --wait 120
            --json
            --manifest "changed-sources/package/package.xml"
          )

          # If sfdx-git-delta produced destructive manifests, include them in the same validation
          if [ -f "changed-sources/destructiveChanges/destructiveChanges.xml" ]; then
            flags+=( --pre-destructive-changes "changed-sources/destructiveChanges/destructiveChanges.xml" )
          fi
          if [ -f "changed-sources/destructiveChangesPost/destructiveChanges.xml" ]; then
            flags+=( --post-destructive-changes "changed-sources/destructiveChangesPost/destructiveChanges.xml" )
          fi

          echo "::group::Run validation"
          # Run validate but do NOT let a non-zero exit kill the step yet; capture both streams
          set +e
          sf project deploy validate "${flags[@]}" --verbose > "prod-validate.json" 2> "sf-validate.stderr"
          rc=$?
          set -e
          echo "sf project deploy validate exit code: ${rc}"
          echo "::endgroup::"

          echo "::group::Parse/diagnose results"
          # If JSON looks valid, parse it; otherwise show stderr and fail clearly
          if jq -e . >/dev/null 2>&1 < "prod-validate.json"; then
            VALIDATE_ID="$(jq -r '.id // .result.id // empty' "prod-validate.json" 2>/dev/null || true)"
            status="$(jq -r '.status // .result.status // "unknown"' "prod-validate.json" 2>/dev/null || echo "unknown")"
            failures="$(jq '.result.details.runTestResult.failures | length // 0' "prod-validate.json" 2>/dev/null || echo 0)"
          else
            echo "::warning::prod-validate.json is not valid JSON. Dumping sf-validate.stderr (first 200 lines):"
            sed -n '1,200p' sf-validate.stderr || true
            echo "::error::Salesforce CLI did not produce valid JSON. See stderr above."
            exit 1
          fi

          # Expose outputs for later steps
          echo "validate_id=${VALIDATE_ID}" >> "$GITHUB_OUTPUT"
          printf '%s' "${VALIDATE_ID:-}" > "prod-validate-id.txt" || true
          echo "status=${status}"   >> "$GITHUB_OUTPUT"
          echo "failures=${failures}" >> "$GITHUB_OUTPUT"

          # Brief summary to logs
          echo "Validation status: ${status}; failures: ${failures}"

          # If the CLI exited non-zero but still produced JSON, we keep going and let callers decide.
          # If you want to fail here on test failures, uncomment:
          # if [[ "${failures}" -gt 0 ]]; then
          #   echo "::error::Apex test failures: ${failures}"
          #   exit 1
          # fi
          echo "::endgroup::"


      - name: Upload prod validation JSON artifacts
        if: steps.outputs.skip_process != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: prod-validate-pr-${{ github.event.pull_request.number }}
          path: |
            prod-validate.json
            prod-validate-id.txt


      - name: Comment results on the PR and fail on test errors
        if: steps.outputs.skip_process != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner, repo = context.repo.repo;
            const number = context.payload.pull_request.number;

            const file = 'prod-validate.json';
            const idPath = 'prod-validate-id.txt';
            let body = "### Production validation result (Quick Deploy–ready)\n\n";

            let validateId = '';
            if (fs.existsSync(idPath)) {
              validateId = fs.readFileSync(idPath, 'utf8').trim();
            }

            let failures = [];
            let deployStatus = 'unknown';
            if (fs.existsSync(file)) {
              try {
                const data = JSON.parse(fs.readFileSync(file,'utf8'));
                failures = (((data || {}).result || {}).details || {}).runTestResult?.failures || [];
                deployStatus = data?.status || (data?.result?.status) || 'unknown';
              } catch (e) {
                body += `Could not parse prod-validate.json: ${e.message}\n\n`;
              }
            } else {
              body += "No prod-validate.json produced; check workflow logs.\n\n";
            }

            body += `Status: **${deployStatus}**\n\n`;
            if (validateId) {
              body += `**Validation ID:** \`${validateId}\`\n\n`;
              body += `You can Quick Deploy later with:\n\n`;
              body += "```bash\n";
              body += `sf project deploy quick --target-org ProdForValidation --job-id ${validateId} --wait 120 --json\n`;
              body += "```\n\n";
            }

            if (failures.length) {
              body += `Found **${failures.length}** failing Apex test(s):\n\n| Class | Method | Message |\n|---|---|---|\n`;
              for (const f of failures.slice(0,30)) {
                const msg = String(f.message || '').replace(/\n/g, ' ').slice(0,500);
                body += `| ${f.name} | ${f.methodName} | ${msg} |\n`;
              }
              body += `\n(Full validation JSON uploaded as artifact.)\n`;
            } else {
              body += "No Apex test failures found.\n";
            }

            await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
            if (failures.length) core.setFailed(`Prod validation reported ${failures.length} Apex failures.`);
