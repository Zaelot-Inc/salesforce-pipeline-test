name: Generate deploy manifests + PR instructions (no auto validation)

on:
  pull_request:
    branches: [ main ]
    types: [ opened, reopened, synchronize, ready_for_review ]
  workflow_call:
    inputs:
      ref:
        description: "Release branch / SHA to validate"
        required: true
        type: string
      pr_number:
        description: "Origin PR number (for comments)"
        required: false
        type: string
      pr_title:
        description: "Origin PR title (for messages)"
        required: false
        type: string

permissions:
  contents: write          # we commit manifests into the PR branch (same-repo PRs)
  pull-requests: write

concurrency:
  group: 'main-pr-manifests-${{ github.event.pull_request.number }}'
  cancel-in-progress: true

jobs:
  build-manifests-and-comment:
    name: Build delta manifests + PR comment
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ inputs.ref || github.sha }}


      - name: Debug context (event + inputs)
        run: |
          echo "event_name=${{ github.event_name }}"
          echo "inputs.ref=${{ inputs.ref || '' }}"
          echo "pull_request.number=${{ github.event.pull_request.number || '' }}"
          echo "github.sha=${{ github.sha }}"
          echo "github.ref=${{ github.ref }}"
    # If invoked via workflow_call, synthesize PR context for downstream steps
      - name: Set PR context (workflow_call)
        if: ${{ github.event_name == 'workflow_call' }}
        shell: bash
        run: |
          echo "PR_NUM=${{ inputs.pr_number || '0' }}" >> $GITHUB_ENV
          echo "PR_TITLE=${{ inputs.pr_title || 'Release validation (workflow_call)' }}" >> $GITHUB_ENV
          echo "PR_HEAD_REF=${{ inputs.ref }}" >> $GITHUB_ENV
          echo "PR_HEAD_SHA=${{ inputs.ref }}" >> $GITHUB_ENV


      # Quick guard: does the PR touch force-app at all?
      - name: Detect force-app changes
        id: touched
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              { owner, repo, pull_number: number, per_page: 100 }
            );
            const hasForceApp = files.some(f => f.filename.startsWith('force-app/'));
            core.setOutput('has_force_app', hasForceApp ? 'true' : 'false');

      # If NO force-app changes at all, exit gracefully
      - name: No force-app changes (success)
        if: steps.touched.outputs.has_force_app != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: "ℹ️ Skipping manifest generation: this PR does not touch `force-app/**`."
            });

      - name: Install requirements (sf CLI, sfdx-git-delta, jq)
        if: steps.touched.outputs.has_force_app == 'true'
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true

      - name: Ensure Java 11 (needed by some plugins)
        if: steps.touched.outputs.has_force_app == 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'zulu'

      # Prefer the "PR merge" ref (what will land); fallback to PR head if merge ref isn't available.
      - name: Prepare refs (origin/main + PR merge, with fallback to head)
        if: steps.touched.outputs.has_force_app == 'true'
        shell: bash
        env:
          PR_NUM:   ${{ github.event.pull_request.number }}
          GH_REPO:  ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GH_REPO}.git"
          git fetch --no-tags origin main:refs/remotes/origin/main
          git rev-parse --verify refs/remotes/origin/main

          TO_REF="HEAD"

          if [ "${{ github.event_name }}" = "workflow_call" ]; then
            # Reusable call: TO_REF is exactly what the caller provided
            TO_REF='${{ inputs.ref }}'
            echo "Using TO_REF from workflow_call: ${TO_REF}"
          else
            # PR run: fetch the PR merge ref (fallback to head if no merge ref)
            PR_NUM='${{ github.event.pull_request.number }}'
            git fetch --no-tags origin main:refs/remotes/origin/main
            if git fetch --no-tags origin "refs/pull/${PR_NUM}/merge:refs/remotes/origin/pr-${PR_NUM}-merge"; then
              TO_REF="refs/remotes/origin/pr-${PR_NUM}-merge"
              echo "Using PR merge ref."
            else
              git fetch --no-tags origin "refs/pull/${PR_NUM}/head:refs/remotes/origin/pr-${PR_NUM}-head"
              TO_REF="refs/remotes/origin/pr-${PR_NUM}-head"
              echo "PR not mergeable; using head ref."
            fi
          fi

          echo "TO_REF=${TO_REF}" >> "$GITHUB_ENV"
      - name: Debug refs
        run: |
          echo "Using TO_REF=$TO_REF"
          git log -1 --oneline "$TO_REF"

      - name: Generate delta (origin/main -> $TO_REF)
        if: steps.touched.outputs.has_force_app == 'true'
        id: delta
        shell: bash
        run: |
          set -euo pipefail # This 'set -e' is the source of the problem
          rm -rf changed-sources
          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to   "${TO_REF}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          has_addmods="false"
          has_deletions="false"
          
          [ -d changed-sources/force-app ] && [ -n "$(ls -A changed-sources/force-app || true)" ] && has_addmods="true"
          
          echo "Checking for destructive changes..."

          if [ -f changed-sources/destructiveChanges/destructiveChanges.xml ]; then
            echo "Found destructiveChanges.xml, checking for <members>..."
            if grep -q "<members>" changed-sources/destructiveChanges/destructiveChanges.xml; then
              echo "Found <members> in destructiveChanges.xml."
              has_deletions="true"
            else
              echo "File is empty or contains no <members>."
            fi
          fi
          
          if [ -f changed-sources/destructiveChangesPost/destructiveChanges.xml ]; then
            echo "Found destructiveChangesPost.xml, checking for <members>..."
            if grep -q "<members>" changed-sources/destructiveChangesPost/destructiveChanges.xml; then
              echo "Found <members> in destructiveChangesPost.xml."
              has_deletions="true"
            else
              echo "File is empty or contains no <members>."
            fi
          fi

          echo "has_addmods=${has_addmods}"     >> "$GITHUB_OUTPUT"
          echo "has_deletions=${has_deletions}" >> "$GITHUB_OUTPUT"

          if [ "${has_addmods}" != "true" ] && [ "${has_deletions}" != "true" ]; then
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
          else
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Early exit if no metadata changes
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const number = context.payload.pull_request.number;
            await github.rest.issues.createComment({
              owner, repo, issue_number: number,
              body: "ℹ️ No delta found between `main` and this PR — no manifests generated."
            });

      - name: Build branch-safe name + output paths
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        id: naming
        shell: bash
        run: |
          set -euo pipefail
          RAW="${{ github.event.pull_request.head.ref }}"
          SAFE="$(printf "%s" "$RAW" | sed -E 's/[^A-Za-z0-9._-]+/-/g')"
          PKG="manifest/branch/${SAFE}-package.xml"
          DEST="manifest/branch/${SAFE}-package-destructive.xml"
          echo "branch_raw=${RAW}"  >> "$GITHUB_OUTPUT"
          echo "branch_safe=${SAFE}" >> "$GITHUB_OUTPUT"
          echo "pkg_path=${PKG}"     >> "$GITHUB_OUTPUT"
          echo "dest_path=${DEST}"   >> "$GITHUB_OUTPUT"

      - name: Create manifest/branch/<branch>-package.xml (adds/mods)
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${{ steps.naming.outputs.pkg_path }}")"
          if [ -f "changed-sources/package/package.xml" ]; then
            cp "changed-sources/package/package.xml" "${{ steps.naming.outputs.pkg_path }}"
          else
            # deletion-only changes -> synthesize a minimal, valid package.xml
            API_VER="$(jq -r '.sourceApiVersion // empty' sfdx-project.json 2>/dev/null || true)"
            API_VER="${API_VER:-64.0}"
            
            echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
            <Package xmlns=\"http://soap.sforce.com/2006/04/metadata\">
              <version>${API_VER}</version>
            </Package>" > "${{ steps.naming.outputs.pkg_path }}"
          fi

      - name: Create manifest/branch/<branch>-package-destructive.xml (if deletions)
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.has_deletions == 'true'
        shell: bash
        env:
          # This correctly passes the variable TO the Python script
          DEST_PATH: ${{ steps.naming.outputs.dest_path }}
        run: |
          set -euo pipefail
          
          # This is a debug step, "checking the obvious"
          echo "DEST_PATH is set to: ${DEST_PATH}"
          
          # Now, execute the Python script
          python3 .github/scripts/merge_destructive.py
      - name: Can we push to this PR branch?
        id: canpush
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const sameRepo = context.payload.pull_request.head.repo?.full_name === context.repo.owner + '/' + context.repo.repo;
            core.setOutput('same_repo', sameRepo ? 'true' : 'false');

      - name: Commit manifests into the PR branch
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true' && steps.canpush.outputs.same_repo == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          IS_WF:     ${{ github.event_name == 'workflow_call' }}
          PR_NUM:    ${{ github.event.pull_request.number }}
          INPUT_REF: ${{ inputs.ref }}  # only populated in workflow_call
        run: |
          set -euo pipefail

          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config user.name  "github-actions[bot]"
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git"

          # --- Resolve target branch we will push to ---
          TARGET_BRANCH=""
          if [ "${IS_WF}" = "true" ] && [ -n "${INPUT_REF:-}" ]; then
            # inputs.ref may be 'release/...' or a SHA; we only push to branches
            case "${INPUT_REF}" in
              refs/heads/*) TARGET_BRANCH="${INPUT_REF#refs/heads/}";;
              *)             TARGET_BRANCH="${INPUT_REF}";;
            esac
          else
            TARGET_BRANCH='${{ github.event.pull_request.head.ref }}'
          fi

          if [ -z "${TARGET_BRANCH}" ]; then
            echo "::error::Could not determine target branch for manifest commit."
            exit 1
          fi
          echo "Target branch: ${TARGET_BRANCH}"

          # --- Ensure we are based on the latest remote tip of that branch ---
          git fetch --no-tags origin "${TARGET_BRANCH}:refs/remotes/origin/${TARGET_BRANCH}" || true

          if git show-ref --verify --quiet "refs/remotes/origin/${TARGET_BRANCH}"; then
            git checkout -B "${TARGET_BRANCH}" "refs/remotes/origin/${TARGET_BRANCH}"
          else
            # If branch doesn't exist yet (rare for PRs), create it off main
            git fetch --no-tags origin main:refs/remotes/origin/main
            git checkout -B "${TARGET_BRANCH}" refs/remotes/origin/main
          fi

          # --- Stage manifest changes ---
          # Adjust paths to your manifest outputs
          if [ -d "manifest/branch" ] && find manifest/branch -type f -print -quit | grep -q .; then
            git add -A manifest/branch
          fi
          if git diff --cached --quiet; then
            echo "No manifest changes to commit."
            exit 0
          fi

          git commit -m "chore(manifest): update delta manifests for PR #${PR_NUM:-0}"

          # --- Safe push with lease ---
          # Determine the remote tip we fetched; lease ensures we don't clobber newer commits
          REMOTE_TIP="$(git rev-parse "refs/remotes/origin/${TARGET_BRANCH}" 2>/dev/null || echo "")"
          if [ -n "${REMOTE_TIP}" ]; then
            echo "Remote tip is ${REMOTE_TIP}"
            if ! git push --force-with-lease=refs/heads/${TARGET_BRANCH}:${REMOTE_TIP} origin "HEAD:${TARGET_BRANCH}"; then
              echo "::error::Could not push manifests: remote branch '${TARGET_BRANCH}' moved during this run."
              echo "Resolve by re-running the job (or merge latest into your release branch) and try again."
              exit 2
            fi
          else
            echo "Remote branch didn't exist; creating it."
            git push --set-upstream origin "HEAD:${TARGET_BRANCH}"
          fi

      - name: Upload manifests as artifact (fork PRs / no push)
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true' && steps.canpush.outputs.same_repo != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: pr-${{ github.event.pull_request.number }}-manifests
          path: |
            ${{ steps.naming.outputs.pkg_path }}
            ${{ steps.naming.outputs.dest_path }}
      - name: Comment instructions on the PR
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;

            // Get all your variables from previous steps
            const branch = "${{ steps.naming.outputs.branch_safe }}";
            const pkg = "${{ steps.naming.outputs.pkg_path }}";
            const dest = "${{ steps.naming.outputs.dest_path }}";
            const hasDel = "${{ steps.delta.outputs.has_deletions }}" === "true";
            const canPush = "${{ steps.canpush.outputs.same_repo }}" === "true";

            // Read the template file from the repository
            let body = fs.readFileSync('.github/templates/how-to-deploy-prod.md', 'utf8');

            // --- Helper function to remove conditional blocks ---
            const removeBlock = (tag, content) => {
              const regex = new RegExp(`<!-- ${tag} -->[\\s\\S]*?<!-- END${tag} -->`, 'g');
              return content.replace(regex, '');
            };
            
            // --- 1. Handle Conditional Blocks ---
            if (hasDel) {
              // Deletions exist: remove the "no destructive" block and the "destructive" line
              body = removeBlock('IF_NO_DESTRUCTIVE', body);
            } else {
              // No deletions: remove the "destructive" blocks
              body = removeBlock('IF_DESTRUCTIVE', body);
            }
            
            if (canPush) {
              // It's a same-repo PR, so remove the "fork" message
              body = removeBlock('IF_FORK_PR', body);
            }
            
            // Clean up any remaining conditional tags (the ones we decided to keep)
            body = body.replace(/<!-- \/?IF_.*? -->/g, '');

            // --- 2. Replace Placeholders ---
            body = body.replace(/{{BRANCH_SAFE}}/g, branch);
            body = body.replace(/{{PKG_PATH}}/g, pkg);
            body = body.replace(/{{DEST_PATH}}/g, dest);

            // --- 3. Post the Comment ---
            await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
