name: Validate release PR against Production (check-only)

on:
  pull_request:
    branches: [ main ]
    types: [ opened, reopened, synchronize, ready_for_review ]
    # this filter already helps, but we also add a runtime guard below

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: 'prod-validate-pr-${{ github.event.pull_request.number }}'
  cancel-in-progress: true

jobs:
  prod-validate:
    name: Prod validate-only (origin/main -> PR head)
    runs-on: ubuntu-latest
    env:
      SF_LOGIN_URL_PROD: "https://test.salesforce.com"

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # NEW: detect whether the PR actually touches force-app/**
      - name: Detect force-app changes
        id: touched
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: number, per_page: 100 });
            const hasForceApp = files.some(f => f.filename.startsWith('force-app/'));
            core.setOutput('has_force_app', hasForceApp ? 'true' : 'false');

      # If NO force-app changes, succeed and stop
      - name:  no force-app changes (success)
        if: steps.touched.outputs.has_force_app != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: "ℹ️ Skipping Production validation: this PR does not touch `force-app/**`."
            });
            // success by default (no failure)

      - name: Install requirements (sf CLI, sfdx-git-delta, jq)
        if: steps.touched.outputs.has_force_app == 'true'
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true

      - name: Ensure Java 11+
        if: steps.touched.outputs.has_force_app == 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'zulu'

      - name: Prepare refs (origin/main)
        if: steps.touched.outputs.has_force_app == 'true'
        run: |
          set -euo pipefail
          git fetch --no-tags origin main:refs/remotes/origin/main
          git rev-parse --verify origin/main
          echo "HEAD of PR: ${{ github.event.pull_request.head.sha }}"

      - name: Generate delta (origin/main -> PR head)
        id: delta
        run: |
          set -euo pipefail
          TO_SHA="${{ github.event.pull_request.head.sha }}"
          echo "Generating delta: origin/main -> ${TO_SHA}"
          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to   "${TO_SHA}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          has_addmods="false"
          has_deletions="false"

          if [ -d changed-sources/force-app ] && [ -n "$(ls -A changed-sources/force-app || true)" ]; then
            has_addmods="true"
          fi
          if [ -f "changed-sources/destructiveChanges/destructiveChanges.xml" ] || \
            [ -f "changed-sources/destructiveChangesPost/destructiveChanges.xml" ]; then
            has_deletions="true"
          fi

          echo "has_addmods=$has_addmods"     >> "$GITHUB_OUTPUT"
          echo "has_deletions=$has_deletions" >> "$GITHUB_OUTPUT"


      - name: Early exit if no metadata changes
        id: early
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.has_addmods != 'true' && steps.delta.outputs.has_deletions != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner, repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const body = "ℹ️ No deployable metadata differences detected between `main` and this PR — skipping Production validation.";
            await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
            core.setOutput('skip_process', 'true');
     
      - name: Write Prod JWT key
        if: steps.outputs.skip_process != 'true'
        env:
          SF_JWT_KEY_PROD: ${{ secrets.SF_JWT_KEY }}
        run: |
          set -euo pipefail
          [ -z "${SF_JWT_KEY_PROD:-}" ] && { echo "SF_JWT_KEY_PROD missing"; exit 1; }
          umask 177
          printf "%s" "$SF_JWT_KEY_PROD" > jwt_prod.key
      - name: Sanity check JWT env
        env:
          SF_JWT_CLIENT_PROD: ${{ secrets.SF_JWT_CLIENT }}
          SF_JWT_USERNAME_PROD: ${{ secrets.SF_JWT_USERNAME }}
        run: |
          echo "Endpoint: ${SF_LOGIN_URL_PROD}"
          echo "Client ID length: ${#SF_JWT_CLIENT_PROD}"
          echo "Username: ${#SF_JWT_USERNAME_PROD}"
          openssl rsa -in jwt_prod.key -check -noout >/dev/null && echo "Private key OK" || (echo "Bad private key"; exit 1)
          
      - name: Login to Production (JWT)
        if: steps.outputs.skip_process != 'true'
        env:
          SF_JWT_CLIENT_PROD: ${{ secrets.SF_JWT_CLIENT }}
          SF_JWT_USERNAME_PROD: ${{ secrets.SF_JWT_USERNAME }}
        run: |
          set -euo pipefail
          sf org login jwt \
            --username "$SF_JWT_USERNAME_PROD" \
            --client-id "$SF_JWT_CLIENT_PROD" \
            --jwt-key-file jwt_prod.key \
            --instance-url "${SF_LOGIN_URL_PROD}" \
            --alias ProdForValidation --set-default --json

      # 1) Run validation with full capture and produce a comment body
      - name: Validate-only deploy to Production (capture & summarize)
        id: prod_validate
        shell: bash
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -Eeuo pipefail
          PS4='+ [${BASH_SOURCE##*/}:${LINENO}] '; set -x

          # --- Detect what we have to validate ---
          HAS_ADDMODS=0; HAS_PRE=0; HAS_POST=0
          if [ -d "changed-sources/force-app" ] && [ -n "$(ls -A changed-sources/force-app || true)" ]; then HAS_ADDMODS=1; fi
          [ -s "changed-sources/destructiveChanges/destructiveChanges.xml" ] && HAS_PRE=1 || true
          [ -s "changed-sources/destructiveChangesPost/destructiveChanges.xml" ] && HAS_POST=1 || true

          # Ensure a minimal manifest (needed for destructive-only)
          if [ ! -f "changed-sources/package/package.xml" ]; then
            mkdir -p changed-sources/package
            API_VER="$(jq -r '.sourceApiVersion // .packageDirectories[0].versionNumber // empty' sfdx-project.json 2>/dev/null || true)"
            API_VER="${API_VER:-60.0}"
            printf '%s\n' \
              '<?xml version="1.0" encoding="UTF-8"?>' \
              '<Package xmlns="http://soap.sforce.com/2006/04/metadata">' \
              "  <version>${API_VER}</version>" \
              '</Package>' > changed-sources/package/package.xml
          fi

          # If truly nothing to validate, short-circuit success and generate comment
          if [ "$HAS_ADDMODS" -eq 0 ] && [ "$HAS_PRE" -eq 0 ] && [ "$HAS_POST" -eq 0 ]; then
            echo "skipped=true" >> "$GITHUB_OUTPUT"
            {
              echo "### Production validation"
              echo ""
              echo "ℹ️ Skipped: This PR does not introduce deployable metadata (no additions/modifications) and has no destructive changes."
            } > pr-comment.md
            printf '' > prod-validate.json
            printf '' > sf-validate.stderr
            exit 0
          fi

          # Build flags
          flags=(
            --target-org ProdForValidation
            --test-level RunLocalTests
            --wait 120
            --json
            --manifest "changed-sources/package/package.xml"
          )
          [ "$HAS_PRE"  -eq 1 ] && flags+=( --pre-destructive-changes  "changed-sources/destructiveChanges/destructiveChanges.xml" )
          [ "$HAS_POST" -eq 1 ] && flags+=( --post-destructive-changes "changed-sources/destructiveChangesPost/destructiveChanges.xml" )

          # --- Run validation (do NOT abort on non-zero) ---
          set +e
          sf project deploy validate "${flags[@]}" --verbose > prod-validate.json 2> sf-validate.stderr
          RC=$?
          set -e
          echo "rc=${RC}" >> "$GITHUB_OUTPUT"

          # Parse JSON when present; otherwise we’ll show stderr
          JSON_OK=0
          if jq -e . >/dev/null 2>&1 < prod-validate.json; then JSON_OK=1; fi
          echo "json_ok=${JSON_OK}" >> "$GITHUB_OUTPUT"

          VALIDATE_ID="$(jq -r '.id // .result.id // empty' prod-validate.json 2>/dev/null || true)"
          STATUS="$(jq -r '.status // .result.status // "unknown"' prod-validate.json 2>/dev/null || echo "unknown")"
          FAILURES="$(jq '.result.details.runTestResult.failures | length // 0' prod-validate.json 2>/dev/null || echo 0)"

          echo "validate_id=${VALIDATE_ID}" >> "$GITHUB_OUTPUT"
          echo "status=${STATUS}" >> "$GITHUB_OUTPUT"
          echo "failures=${FAILURES}" >> "$GITHUB_OUTPUT"

          # Build a Markdown comment body with the best info we have
          {
            echo "### Production validation"
            echo ""
            if [ "$JSON_OK" -eq 1 ]; then
              echo "**Status:** \`${STATUS}\`  •  **Apex failures:** \`${FAILURES}\`"
              echo ""
              if [ "$FAILURES" -gt 0 ]; then
                echo "| Class | Method | Message |"
                echo "|---|---|---|"
                jq -r '
                  (((.result.details.runTestResult.failures // []) | .[0:30]) // [])
                  | .[] | [(.name // "-"), (.methodName // "-"),
                    ((.message // "" | gsub("\n"; " ") | .[0:500]))] | @tsv
                ' prod-validate.json | awk -F'\t' '{printf("| %s | %s | %s |\n",$1,$2,$3)}'
                echo ""
                echo "_(Full JSON attached as artifact)_"
              else
                echo "No Apex test failures reported."
              fi
            else
              echo "**Status:** \`unknown\`  •  CLI returned a non-JSON error. See excerpt below."
              echo ""
              echo "#### CLI error (first 200 lines)"
              echo '```'
              sed -n '1,200p' sf-validate.stderr || true
              echo '```'
            fi
          } > pr-comment.md

          # If you want to fail the job on validation error or test failures, do it here after writing outputs/comment.
          if [ "$RC" -ne 0 ]; then
            echo "will_fail=true" >> "$GITHUB_OUTPUT"
          elif [ "$FAILURES" -gt 0 ]; then
            echo "will_fail=true" >> "$GITHUB_OUTPUT"
          else
            echo "will_fail=false" >> "$GITHUB_OUTPUT"
          fi

      # 2) Upload artifacts so you can inspect locally
      - name: Upload validation artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: prod-validation-${{ github.event.pull_request.number }}
          path: |
            prod-validate.json
            sf-validate.stderr
            pr-comment.md

      # 3) Post the result to the PR and (optionally) fail the job
      - name: Comment results on PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner, repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const body = fs.existsSync('pr-comment.md')
              ? fs.readFileSync('pr-comment.md','utf8')
              : 'Production validation ran but no summary was produced.';
            await github.rest.issues.createComment({ owner, repo, issue_number: number, body });

            // Fail the job if the validator said so (keeps the PR comment posted)
            const willFail = "${{ steps.prod_validate.outputs.will_fail }}";
            if (willFail === 'true') {
              core.setFailed('Production validation reported failures or CLI error. See comment above and artifacts.');
            }
