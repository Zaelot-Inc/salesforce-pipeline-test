name: Generate deploy manifests + PR instructions (no auto validation)

on:
  pull_request:
    branches: [ main ]
    types: [ opened, reopened, synchronize, ready_for_review ]

permissions:
  contents: write          # we commit manifests into the PR branch (same-repo PRs)
  pull-requests: write

concurrency:
  group: 'main-pr-manifests-${{ github.event.pull_request.number }}'
  cancel-in-progress: true

jobs:
  build-manifests-and-comment:
    name: Build delta manifests + PR comment
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # Quick guard: does the PR touch force-app at all?
      - name: Detect force-app changes
        id: touched
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              { owner, repo, pull_number: number, per_page: 100 }
            );
            const hasForceApp = files.some(f => f.filename.startsWith('force-app/'));
            core.setOutput('has_force_app', hasForceApp ? 'true' : 'false');

      # If NO force-app changes at all, exit gracefully
      - name: No force-app changes (success)
        if: steps.touched.outputs.has_force_app != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: "ℹ️ Skipping manifest generation: this PR does not touch `force-app/**`."
            });

      - name: Install requirements (sf CLI, sfdx-git-delta, jq)
        if: steps.touched.outputs.has_force_app == 'true'
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true

      - name: Ensure Java 11 (needed by some plugins)
        if: steps.touched.outputs.has_force_app == 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'zulu'

      # Prefer the "PR merge" ref (what will land); fallback to PR head if merge ref isn't available.
      - name: Prepare refs (origin/main + PR merge, with fallback to head)
        if: steps.touched.outputs.has_force_app == 'true'
        shell: bash
        env:
          PR_NUM:   ${{ github.event.pull_request.number }}
          GH_REPO:  ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GH_REPO}.git"
          git fetch --no-tags origin main:refs/remotes/origin/main
          git rev-parse --verify refs/remotes/origin/main

          if git fetch --no-tags origin "refs/pull/${PR_NUM}/merge:refs/remotes/origin/pr-${PR_NUM}-merge"; then
            echo "TO_REF=refs/remotes/origin/pr-${PR_NUM}-merge" >> "$GITHUB_ENV"
            echo "Using PR merge ref."
          else
            echo "PR merge ref not available (likely conflicts). Falling back to PR head."
            git fetch --no-tags origin "refs/pull/${PR_NUM}/head:refs/remotes/origin/pr-${PR_NUM}-head"
            git rev-parse --verify "refs/remotes/origin/pr-${PR_NUM}-head"
            echo "TO_REF=refs/remotes/origin/pr-${PR_NUM}-head" >> "$GITHUB_ENV"
          fi

      - name: Generate delta (origin/main -> $TO_REF)
        if: steps.touched.outputs.has_force_app == 'true'
        id: delta
        shell: bash
        run: |
          set -euo pipefail
          rm -rf changed-sources
          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to   "${TO_REF}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          has_addmods="false"
          has_deletions="false"
          [ -d changed-sources/force-app ] && [ -n "$(ls -A changed-sources/force-app || true)" ] && has_addmods="true"
          [ -f changed-sources/destructiveChanges/destructiveChanges.xml ] && has_deletions="true"
          [ -f changed-sources/destructiveChangesPost/destructiveChanges.xml ] && has_deletions="true"

          echo "has_addmods=${has_addmods}"     >> "$GITHUB_OUTPUT"
          echo "has_deletions=${has_deletions}" >> "$GITHUB_OUTPUT"

          if [ "${has_addmods}" != "true" ] && [ "${has_deletions}" != "true" ]; then
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
          else
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Early exit if no metadata changes
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const number = context.payload.pull_request.number;
            await github.rest.issues.createComment({
              owner, repo, issue_number: number,
              body: "ℹ️ No delta found between `main` and this PR — no manifests generated."
            });

      - name: Build branch-safe name + output paths
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        id: naming
        shell: bash
        run: |
          set -euo pipefail
          RAW="${{ github.event.pull_request.head.ref }}"
          SAFE="$(printf "%s" "$RAW" | sed -E 's/[^A-Za-z0-9._-]+/-/g')"
          PKG="manifest/branch/${SAFE}-package.xml"
          DEST="manifest/branch/${SAFE}-package-destructive.xml"
          echo "branch_raw=${RAW}"  >> "$GITHUB_OUTPUT"
          echo "branch_safe=${SAFE}" >> "$GITHUB_OUTPUT"
          echo "pkg_path=${PKG}"     >> "$GITHUB_OUTPUT"
          echo "dest_path=${DEST}"   >> "$GITHUB_OUTPUT"

      - name: Create manifest/branch/<branch>-package.xml (adds/mods)
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${{ steps.naming.outputs.pkg_path }}")"
          if [ -f "changed-sources/package/package.xml" ]; then
            cp "changed-sources/package/package.xml" "${{ steps.naming.outputs.pkg_path }}"
          else
            # deletion-only changes -> synthesize a minimal, valid package.xml
            API_VER="$(jq -r '.sourceApiVersion // empty' sfdx-project.json 2>/dev/null || true)"
            API_VER="${API_VER:-60.0}"
            
            # Use echo. This is clean and avoids all indentation issues.
            echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
            <Package xmlns=\"http://soap.sforce.com/2006/04/metadata\">
              <version>${API_VER}</version>
            </Package>" > "${{ steps.naming.outputs.pkg_path }}"
          fi

      - name: Create manifest/branch/<branch>-package-destructive.xml (if deletions)
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.has_deletions == 'true'
        shell: bash
        env:
          # This correctly passes the variable TO the Python script
          DEST_PATH: ${{ steps.naming.outputs.dest_path }}
        run: |
          set -euo pipefail
          
          # This is a debug step, "checking the obvious"
          echo "DEST_PATH is set to: ${DEST_PATH}"
          
          # Now, execute the Python script
          python3 .github/scripts/merge_destructive.py
      - name: Can we push to this PR branch?
        id: canpush
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const sameRepo = context.payload.pull_request.head.repo?.full_name === context.repo.owner + '/' + context.repo.repo;
            core.setOutput('same_repo', sameRepo ? 'true' : 'false');

      - name: Commit manifests into the PR branch
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true' && steps.canpush.outputs.same_repo == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config user.name  "github-actions[bot]"
          git add -A -- "manifest/branch"
          if git diff --cached --quiet; then
            echo "Manifests unchanged; nothing to commit."
            exit 0
          fi
          git commit -m "chore(manifest): generate delta manifests for PR #${{ github.event.pull_request.number }}"
          git push origin "HEAD:${{ github.event.pull_request.head.ref }}"

      - name: Upload manifests as artifact (fork PRs / no push)
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true' && steps.canpush.outputs.same_repo != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: pr-${{ github.event.pull_request.number }}-manifests
          path: |
            ${{ steps.naming.outputs.pkg_path }}
            ${{ steps.naming.outputs.dest_path }}

      - name: Comment instructions on the PR
        if: steps.touched.outputs.has_force_app == 'true' && steps.delta.outputs.no_changes != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner, repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const branch = "${{ steps.naming.outputs.branch_safe }}";
            const pkg = "${{ steps.naming.outputs.pkg_path }}";
            const dest = "${{ steps.naming.outputs.dest_path }}";
            const hasDel = "${{ steps.delta.outputs.has_deletions }}" === "true";
            const canPush = "${{ steps.canpush.outputs.same_repo }}" === "true";
            let body = `### 🔧 Deployment manifests generated for \`${branch}\`\n\n`;
            body += `- Package manifest: \`${pkg}\`\n`;
            if (hasDel && fs.existsSync(dest)) body += `- Destructive manifest: \`${dest}\`\n`;
            if (!canPush) body += `\n_(This PR comes from a fork, so the manifests were uploaded as a workflow artifact instead of being committed.)_\n`;

            body += `\n#### 🚀 How to deploy to **Production** with the \`sf\` CLI\n`;
            body += `> 1) **Authorize** your Prod org (once): \`sf org login jwt --username <user> --client-id <consumerKey> --jwt-key-file <keyfile> --alias Prod\`\n\n`;

            if (!hasDel) {
              body += `**A. Validate (Quick-Deploy eligible)**\n`;
              body += "```bash\n";
              body += `sf project deploy validate \\\n  --manifest ${pkg} \\\n  --target-org Prod \\\n  --test-level RunLocalTests \\\n  --wait 120 \\\n  --json > validate.json\n`;
              body += "```\n";
            } else {
              body += `**A. Validate with destructive changes**\n`;
              body += "_Note: `project deploy validate` historically doesn't accept `--pre/--post-destructive-changes`, so use a check-only deploy which still produces a Quick-Deployable job id._\n";
              body += "```bash\n";
              body += `sf project deploy start \\\n  --manifest ${pkg} \\\n  --pre-destructive-changes ${dest} \\\n  --check-only \\\n  --target-org Prod \\\n  --test-level RunLocalTests \\\n  --wait 120 \\\n  --json > validate.json\n`;
              body += "```\n";
            }

            body += `**B. Quick Deploy (within 10 days, unchanged org):**\n`;
            body += "```bash\n";
            body += `sf project deploy quick --target-org Prod --job-id $(jq -r '.result.id // .id' validate.json) --wait 120 --json\n`;
            body += "```\n";
            body += "\n(Replace `Prod` with your org alias. Save the job id from the validation JSON for quick deploy.)\n";

            await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
