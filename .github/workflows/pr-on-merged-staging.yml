name: Build release branch + validate Prod (on PR merged to staging)

on:
  pull_request:
    types: [closed]
    branches: [staging]

permissions:
  contents: write
  pull-requests: write
  checks: write

jobs:
  promote-feature-branch:
    name: Promote feature branch -> release branch & validate to Prod
    runs-on: ubuntu-latest
    if: ${{ github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'staging' }}
    env:
      SF_LOGIN_URL_PROD: "https://test.salesforce.com"
    outputs:
      release_branch: ${{ steps.create_branch.outputs.release_branch }}
      release_pr_number: ${{ steps.open_pr.outputs.release_pr_number }}
    steps:
      - name: Checkout full repo
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set PR context variables
        id: prinfo
        run: |
          echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          echo "PR_TITLE<<EOF" >> $GITHUB_ENV
          echo "${{ github.event.pull_request.title }}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "PR_HEAD_REF=${{ github.event.pull_request.head.ref }}" >> $GITHUB_ENV
          echo "PR_HEAD_REPO_FULL=${{ github.event.pull_request.head.repo.full_name }}" >> $GITHUB_ENV
          echo "PR_HEAD_OWNER=${{ github.event.pull_request.head.repo.owner.login }}" >> $GITHUB_ENV
          echo "PR_HEAD_REPO=${{ github.event.pull_request.head.repo.name }}" >> $GITHUB_ENV
          echo "PR_HEAD_SHA=${{ github.event.pull_request.head.sha }}" >> $GITHUB_ENV

      - name: Install requirements (sf CLI, sfdx-git-delta, jq, gh)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true
          if ! command -v gh >/dev/null 2>&1; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
              | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
              && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
              && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
              | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
              && sudo apt update && sudo apt install -y gh
          fi

      - name: Ensure Java 11+
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'zulu'

      - name: Fetch origin/main and prepare refs
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          git fetch --no-tags origin main:refs/remotes/origin/main
          git rev-parse --verify origin/main
          echo "PR #${PR_NUMBER}: head=${PR_HEAD_REF} repo=${PR_HEAD_REPO_FULL} sha=${PR_HEAD_SHA}"

      - name: Fetch feature branch (supports forks)
        id: fetch_feature
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          OWNER="${PR_HEAD_OWNER}"
          REPONAME="${PR_HEAD_REPO}"
          BRANCH="${PR_HEAD_REF}"
          PR_NUM="${PR_NUMBER}"
          echo "Fetching '${BRANCH}' from ${OWNER}/${REPONAME} ..."

          if [ "${OWNER}/${REPONAME}" = "${{ github.repository }}" ]; then
            if ! git fetch origin "refs/heads/${BRANCH}:refs/remotes/pr/${BRANCH}"; then
              echo "Direct fetch failed; trying PR ref fallback..."
              git fetch origin "refs/pull/${PR_NUM}/head:refs/remotes/pr/${BRANCH}"
            fi
          else
            git remote remove fork 2>/dev/null || true
            git remote add fork "https://x-access-token:${GH_TOKEN}@github.com/${OWNER}/${REPONAME}.git"
            if ! git fetch --no-tags fork "refs/heads/${BRANCH}:refs/remotes/pr/${BRANCH}"; then
              echo "Fork fetch failed; trying PR ref fallback..."
              git fetch origin "refs/pull/${PR_NUM}/head:refs/remotes/pr/${BRANCH}"
            fi
          fi

          if git show-ref --verify --quiet "refs/remotes/pr/${BRANCH}"; then
            echo "FETCH_REF=refs/remotes/pr/${BRANCH}" >> $GITHUB_ENV
          else
            echo "Could not fetch branch by name; falling back to PR head SHA ${PR_HEAD_SHA}"
            echo "FETCH_REF=${PR_HEAD_SHA}" >> $GITHUB_ENV
          fi

      - name: Generate metadata delta (origin/main -> feature) and set integration ref
        id: gen_delta
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail

          # --- 1) Fetch PR test-merge commit (what staging looked like after merge) ---
          # Useful if you want to validate/deploy the exact merged tree to an Integration org.
          if [ -n "${PR_NUMBER:-}" ]; then
            git fetch --no-tags origin "refs/pull/${PR_NUMBER}/merge:refs/remotes/origin/pr-${PR_NUMBER}-merge" || true
            if git show-ref --verify --quiet "refs/remotes/origin/pr-${PR_NUMBER}-merge"; then
              INTEGRATION_REF="refs/remotes/origin/pr-${PR_NUMBER}-merge"
              echo "Using integration_ref: ${INTEGRATION_REF}"
              echo "integration_ref=${INTEGRATION_REF}" >> "$GITHUB_OUTPUT"
            else
              # Fallback: try to read merge_commit_sha from the event payload
              if [ -f "$GITHUB_EVENT_PATH" ] && command -v jq >/dev/null 2>&1; then
                MERGE_SHA=$(jq -r '.pull_request.merge_commit_sha // empty' "$GITHUB_EVENT_PATH")
                if [ -n "$MERGE_SHA" ]; then
                  echo "integration_ref=${MERGE_SHA}" >> "$GITHUB_OUTPUT"
                  echo "Using integration_ref fallback (merge sha): ${MERGE_SHA}"
                fi
              fi
            fi
          fi

          # --- 2) Build release delta: origin/main -> feature (or PR head SHA) ---
          TO_REF="${FETCH_REF:-${PR_HEAD_SHA}}"
          echo "Generating delta: origin/main -> ${TO_REF}"

          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to "${TO_REF}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          # --- 3) Prepare outputs for downstream steps ---
          if [ -d changed-sources/force-app ] && [ -n "$(ls -A changed-sources/force-app || true)" ]; then
            # list files relative to repo root (strip 'changed-sources/')
            find changed-sources/force-app -type f | sed 's#^changed-sources/##' > changed-files.txt
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
            echo "changed_files_list=changed-files.txt" >> "$GITHUB_OUTPUT"
            echo "delta_to_ref=${TO_REF}" >> "$GITHUB_OUTPUT"
            echo "Delta generated under changed-sources/force-app"
          else
            echo "No changed metadata detected between origin/main and ${TO_REF}"
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
            echo "delta_to_ref=${TO_REF}" >> "$GITHUB_OUTPUT"
          fi

      - name: Abort if no metadata changes
        if: steps.gen_delta.outputs.no_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          BODY="No deployable metadata detected between \`main\` and feature branch \`${PR_HEAD_REF}\` (PR #${PR_NUMBER}). Nothing to promote."
          echo "$BODY"
          gh pr comment "${PR_NUMBER}" --body "$BODY" || true
          exit -1

      - name: Conflict check vs main (merge-base & delta intersection)
        id: conflict_check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          FEATURE_REF="${FETCH_REF}"
          MERGE_BASE=$(git merge-base origin/main "${FEATURE_REF}")
          echo "merge-base: ${MERGE_BASE}"

          git diff --name-only "${MERGE_BASE}" origin/main > files_changed_on_main_since_base.txt

          conflicts=false
          if [ -s changed-files.txt ] && [ -s files_changed_on_main_since_base.txt ]; then
            if grep -xF -f changed-files.txt files_changed_on_main_since_base.txt >/dev/null 2>&1; then
              conflicts=true
            fi
          fi

          if [ "${conflicts}" = "true" ]; then
            BODY="⛔ *Promotion blocked*: Files changed on \`main\` since this branch diverged also appear in the feature delta. Please rebase/merge main into the feature and retry.\n\nOverlap:\n"
            grep -xF -f changed-files.txt files_changed_on_main_since_base.txt | sed -e 's/^/- `/' -e 's/$/`/' >> /tmp/conflict_list.txt || true
            [ -s /tmp/conflict_list.txt ] && BODY="${BODY}$(cat /tmp/conflict_list.txt)\n"
            echo "$BODY"
            gh pr comment "${PR_NUMBER}" --body "$BODY" || true
            exit 1
          else
            echo "No conflicting changes on main detected."
          fi

      - name: Create release branch from origin/main
        id: create_branch
        run: |
          set -euo pipefail
          SHORTSHA=$(echo "${PR_HEAD_SHA}" | cut -c1-7)
          RELEASE_BRANCH="release/pr-${PR_NUMBER}-${SHORTSHA}"
          git checkout -b "${RELEASE_BRANCH}" origin/main
          echo "RELEASE_BRANCH=${RELEASE_BRANCH}" >> $GITHUB_ENV
          echo "release_branch=${RELEASE_BRANCH}" >> $GITHUB_OUTPUT

      - name: Copy delta into release branch and commit
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git config --global user.email "augusto@zaelot.com"
          git config --global user.name "Augusto Presotto"
          rsync -av --delete changed-sources/force-app/ force-app/
          git add -A force-app/
          if git diff --cached --quiet; then
            MSG="Release creation aborted: no changes to commit on release branch for PR #${PR_NUMBER}."
            echo "$MSG"
            gh pr comment "${PR_NUMBER}" --body "$MSG" || true
            exit 0
          fi
          git commit -m "release: promote PR #${PR_NUMBER} (${PR_HEAD_REF} -> main) [automated]"
          git push origin "HEAD:${RELEASE_BRANCH}"

      - name: Open PR from release branch into main
        id: open_pr
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = process.env.RELEASE_BRANCH;
            const base = "main";
            const title = `[release] Promote PR #${process.env.PR_NUMBER} -> main: ${process.env.PR_TITLE}`;
            const body = `Automated release PR to promote feature from staging PR #${process.env.PR_NUMBER}.\n\nFeature branch: \`${process.env.PR_HEAD_REF}\`\nFeature head SHA: \`${process.env.PR_HEAD_SHA}\`\n\nThis PR contains only the metadata delta between \`origin/main\` and the feature branch.`;
            const pr = await github.rest.pulls.create({ owner, repo, title, head, base, body, maintainer_can_modify: true });
            core.info(`Created release PR #${pr.data.number}`);
            core.setOutput('release_pr_number', pr.data.number.toString());
            core.setOutput('release_pr_url', pr.data.html_url);

      - name: Authenticate to Production (JWT) — write key file
        env:
          SF_JWT_KEY_PROD: ${{ secrets.SF_JWT_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${SF_JWT_KEY_PROD:-}" ]; then
            echo "SF_JWT_KEY_PROD not set; skipping prod validation"
            exit 78
          fi
          umask 177
          printf "%s" "$SF_JWT_KEY_PROD" > jwt_prod.key

      - name: Login to Production (JWT)
        env:
          SF_JWT_CLIENT_PROD: ${{ secrets.SF_JWT_CLIENT }}
          SF_JWT_USERNAME_PROD: ${{ secrets.SF_JWT_USERNAME }}
          SF_LOGIN_URL_PROD: ${{ env.SF_LOGIN_URL_PROD }}
        run: |
          set -euo pipefail
          if [ -z "${SF_JWT_CLIENT_PROD:-}" ] || [ -z "${SF_JWT_USERNAME_PROD:-}" ]; then
            echo "SF_JWT_CLIENT_PROD or SF_JWT_USERNAME_PROD not set; skipping prod validation"
            exit 78
          fi
          sf org login jwt \
            --username "$SF_JWT_USERNAME_PROD" \
            --client-id "$SF_JWT_CLIENT_PROD" \
            --jwt-key-file jwt_prod.key \
            --instance-url "${SF_LOGIN_URL_PROD}" \
            --alias ProdForValidation --set-default --json

      - name: Validate-only deploy to Production (check-only)
        run: |
          set -euo pipefail
          if [ ! -d changed-sources/force-app ]; then
            echo "No changed-sources present to validate; skipping prod validation."
            exit 78
          fi

          PROD_VALIDATION_FILE=prod-validate.json
          if ! sf project deploy start \
            --source-dir "changed-sources/force-app" \
            --target-org ProdForValidation \
            --dry-run \
            --test-level RunLocalTests \
            --wait 120 \
            --json > "${PROD_VALIDATION_FILE}" 2>&1; then
            echo "sf project deploy returned non-zero; details captured."
            # fall through to parse JSON/output and fail
          fi

          if [ -s "${PROD_VALIDATION_FILE}" ] && jq -e . >/dev/null 2>&1 < "${PROD_VALIDATION_FILE}"; then
            failures=$(jq '.result.details.runTestResult.failures | length // 0' "${PROD_VALIDATION_FILE}" || echo 0)
            status=$(jq -r '.status // .result.status // "unknown"' "${PROD_VALIDATION_FILE}" || echo "unknown")
            echo "Validation status: ${status}; failures: ${failures}"
            if [ "${failures}" -gt 0 ] || [ "${status}" != "Succeeded" -a "${status}" != "success" ]; then
              exit 1
            fi
          else
            echo "prod-validate.json missing or invalid."
            exit 1
          fi

  rollback-on-failure:
    name: Roll back release artifacts and notify PR (on failure)
    needs: promote-feature-branch
    if: failure()
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Set context
        run: |
          echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          echo "RELEASE_BRANCH=${{ needs.promote-feature-branch.outputs.release_branch }}" >> $GITHUB_ENV
          echo "RELEASE_PR_NUMBER=${{ needs.promote-feature-branch.outputs.release_pr_number }}" >> $GITHUB_ENV

      - name: Install gh
        run: |
          sudo apt-get update -y
          sudo apt-get install -y gh

      - name: Comment failure on original PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          MSG="⛔ Release automation failed. Any created artifacts will be cleaned up. Please review the workflow logs."
          gh pr comment "${PR_NUMBER}" --body "${MSG}" || true

      - name: Close release PR if exists
        if: ${{ env.RELEASE_PR_NUMBER != '' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr close "${RELEASE_PR_NUMBER}" --delete-branch || true

      - name: Delete release branch if still present
        if: ${{ env.RELEASE_BRANCH != '' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # If the PR close already deleted the branch, this is a no-op
          gh api -X DELETE repos/${{ github.repository }}/git/refs/heads/${RELEASE_BRANCH} || true
