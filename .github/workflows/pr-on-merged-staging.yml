name: Build release branch (on PR merged to staging)

on:
  push:
    branches: [staging]

# Ensure only one promotion runs at a time
concurrency:
  group: promote-to-release
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  # Discover the PR that caused this push to 'staging' and ensure it was merged
  guard-and-context:
    name: Resolve PR for this push (must be a merged PR → staging)
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.find.outputs.pr_number }}
      pr_title:  ${{ steps.find.outputs.pr_title }}
      is_merge:  ${{ steps.find.outputs.is_merge }}
      pr_head_ref:   ${{ steps.find.outputs.pr_head_ref }}
      pr_head_sha:   ${{ steps.find.outputs.pr_head_sha }}
      pr_head_owner: ${{ steps.find.outputs.pr_head_owner }}
      pr_head_repo:  ${{ steps.find.outputs.pr_head_repo }}
    steps:
      - name: Find PR associated with this commit
        id: find
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const sha = context.sha;

            // Find PRs tied to this pushed commit
            const prsResp = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner, repo, commit_sha: sha
            });
            // Keep only PRs whose base is 'staging'
            const prs = (prsResp.data || []).filter(pr => pr.base?.ref === 'staging');

            if (!prs.length) {
              core.info('No PR associated with this push to staging. Skipping.');
              core.setOutput('is_merge', 'false');
              return;
            }

            // Take the most recently updated PR and fetch full data to get 'merged' + head info
            const pr = prs.sort((a,b)=> new Date(b.updated_at) - new Date(a.updated_at))[0];
            const prFull = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
            const merged = !!prFull.data.merged;

            core.setOutput('pr_number', String(pr.number));
            core.setOutput('pr_title',  pr.title || '');
            core.setOutput('is_merge',  merged ? 'true' : 'false');

            const head = prFull.data.head || {};
            core.setOutput('pr_head_ref',   head.ref   || '');
            core.setOutput('pr_head_sha',   head.sha   || '');
            core.setOutput('pr_head_owner', head.repo?.owner?.login || '');
            core.setOutput('pr_head_repo',  head.repo?.name || '');

            if (!merged) core.info(`PR #${pr.number} is closed but not merged; skipping.`);

  promote-feature-branch:
    name: Promote feature branch -> release branch
    needs: [guard-and-context]
    if: ${{ needs.guard-and-context.outputs.is_merge == 'true' }}
    runs-on: ubuntu-latest
    env:
      # Example login URL used elsewhere in your pipeline
      SF_LOGIN_URL_PROD: "https://test.salesforce.com"

      # PR context from guard job
      PR_NUMBER:     ${{ needs.guard-and-context.outputs.pr_number }}
      PR_TITLE:      ${{ needs.guard-and-context.outputs.pr_title }}
      PR_HEAD_REF:   ${{ needs.guard-and-context.outputs.pr_head_ref }}
      PR_HEAD_SHA:   ${{ needs.guard-and-context.outputs.pr_head_sha }}
      PR_HEAD_OWNER: ${{ needs.guard-and-context.outputs.pr_head_owner }}
      PR_HEAD_REPO:  ${{ needs.guard-and-context.outputs.pr_head_repo }}
    outputs:
      release_branch: ${{ steps.create_branch.outputs.release_branch }}
      release_pr_number: ${{ steps.open_pr.outputs.release_pr_number }}
    steps:
      # Step 1: Checkout
      - name: Checkout full repo
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false

      # Step 2: Tooling
      - name: Install requirements (sf CLI, sgd, jq, gh)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates rsync
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true
          if ! command -v gh >/dev/null 2>&1; then
            (type -p wget >/dev/null || (sudo apt-get update && sudo apt-get install wget -y)) && \
            sudo mkdir -p -m 755 /etc/apt/keyrings && \
            wget -qO- https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg > /dev/null && \
            sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg && \
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null && \
            sudo apt-get update && \
            sudo apt-get install gh -y
          fi

      - name: Ensure Java 11+
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: zulu

       # Step 3: Fetch main and PR head (ensure all commits are available)
      - name: Build release branch from merged PR (self-contained, preserves history)
        id: build_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"

          # Auth + fetch main
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git"
          git fetch --no-tags origin +refs/heads/main:refs/remotes/origin/main

          # 1) Find the PR into 'staging' associated with this push's head commit
          HEAD_SHA="${GITHUB_SHA}"
          PR_JSON="$(gh api "repos/${REPO}/commits/${HEAD_SHA}/pulls" \
            --jq '[.[] | select(.base.ref=="staging")] | sort_by(.updated_at) | last // empty')"
          if [ -z "${PR_JSON}" ] || [ "${PR_JSON}" = "null" ]; then
            echo "::error::No PR into 'staging' associated with ${HEAD_SHA}."; exit 1;
          fi
          PR_NUM="$(jq -r '.number' <<<"$PR_JSON")"

          # Verify it was merged
          IS_MERGED="$(gh api "repos/${REPO}/pulls/${PR_NUM}" --jq '.merged')"
          if [ "${IS_MERGED}" != "true" ]; then
            echo "::error::PR #${PR_NUM} is not merged into 'staging'."; exit 1;
          fi
          PR_TITLE="$(jq -r '.title // ""' <<<"$PR_JSON")"

          echo "Using merged PR #${PR_NUM} → staging"

          # 2) All PR commits (oldest → newest)
          mapfile -t COMMITS < <(gh api "repos/${REPO}/pulls/${PR_NUM}/commits" --paginate --jq '.[].sha')
          if [ "${#COMMITS[@]}" -eq 0 ]; then
            echo "::error::PR #${PR_NUM} has no commits."; exit 1;
          fi
          FIRST_SHORT="$(echo "${COMMITS[0]}" | cut -c1-7)"
          LAST_SHORT="$(echo "${COMMITS[-1]}" | cut -c1-7)"

          # 3) Create/reuse deterministic release branch from main
          RELEASE_BRANCH="release/pr-${PR_NUM}-${FIRST_SHORT}-${LAST_SHORT}"
          if git show-ref --verify --quiet "refs/heads/${RELEASE_BRANCH}"; then
            git checkout "${RELEASE_BRANCH}"
          elif git ls-remote --exit-code --heads origin "${RELEASE_BRANCH}" >/dev/null 2>&1; then
            git fetch --no-tags origin "refs/heads/${RELEASE_BRANCH}:refs/remotes/origin/${RELEASE_BRANCH}"
            git checkout -b "${RELEASE_BRANCH}" "refs/remotes/origin/${RELEASE_BRANCH}"
          else
            git checkout -B "${RELEASE_BRANCH}" origin/main
          fi


          # 4) Push branch and expose outputs
          git push origin "HEAD:${RELEASE_BRANCH}"
          echo "release_branch=${RELEASE_BRANCH}" >> "$GITHUB_OUTPUT"
          echo "pr_number=${PR_NUM}" >> "$GITHUB_OUTPUT"
          echo "pr_title=${PR_TITLE}" >> "$GITHUB_OUTPUT"
      - name: Configure git identity for automation
        run: |
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global user.name  "github-actions[bot]"

      - name: Cherry-pick PR commits (filter workflows, handle conflicts & empty picks)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          REL_BRANCH: ${{ steps.build_release.outputs.release_branch }}
          SRC_PR_NUM: ${{ steps.build_release.outputs.pr_number }}
        run: |
          set -euo pipefail

          # Ensure release branch is checked out
          if git rev-parse --verify --quiet "refs/heads/${REL_BRANCH}"; then
            git checkout "${REL_BRANCH}"
          elif git ls-remote --exit-code --heads origin "${REL_BRANCH}" >/dev/null 2>&1; then
            git fetch --no-tags origin "refs/heads/${REL_BRANCH}:refs/remotes/origin/${REL_BRANCH}"
            git checkout -b "${REL_BRANCH}" "refs/remotes/origin/${REL_BRANCH}"
          else
            echo "::error::Release branch ${REL_BRANCH} not found."; exit 1
          fi

          mapfile -t COMMITS < <(gh api "repos/${REPO}/pulls/${SRC_PR_NUM}/commits" --paginate --jq '.[].sha')
          if [ "${#COMMITS[@]}" -eq 0 ]; then
            echo "::error::PR #${SRC_PR_NUM} has no commits."; exit 1
          fi

          post_conflict_comment () {
            local PR="$1" BRANCH="$2" FILES="$3" COMMIT="$4"
            local BODY="❌ **Cherry-pick conflict** while promoting PR #${PR} to \`${BRANCH}\` on commit \`${COMMIT}\`.

            **Conflicted files:**
            \`\`\`
            ${FILES}
            \`\`\`

            Please resolve directly on \`${BRANCH}\` (based on \`main\`) and push the fixes."
            gh pr comment "${PR}" --repo "${REPO}" --body "$BODY" || true
          }

          # Strip any .github/workflows/* changes (no workflows permission)
          strip_workflows () {
            git restore --staged --worktree -- .github/workflows || true
            CHANGED=$(git diff --name-only --cached | grep -E '(^|/)\.github/workflows(/|$)' || true)
            if [ -n "$CHANGED" ]; then
              while IFS= read -r p; do
                [ -n "$p" ] && git restore --staged --worktree -- "$p" || true
              done <<< "$CHANGED"
            fi
          }

          # Helper: if in cherry-pick state and index is empty → skip this commit
          skip_if_empty () {
            if [ -f .git/CHERRY_PICK_HEAD ] || [ -d .git/sequencer ]; then
              if git diff --cached --quiet && git diff --quiet; then
                echo "Empty cherry-pick detected → skipping"
                git cherry-pick --skip || true
                return 0
              fi
            fi
            return 1
          }

          for sha in "${COMMITS[@]}"; do
            # Skip if already in main
            if git merge-base --is-ancestor "$sha" origin/main; then
              echo "Skipping $sha (already in main)"; continue
            fi

            echo "::group::Cherry-picking $sha (no-commit)"
            # First attempt: apply without committing so we can filter
            if git cherry-pick -x -n "$sha"; then
              :
            else
              # If there are conflict markers, try one retry favoring PR hunks
              if git diff --name-only --diff-filter=U | grep -q .; then
                echo "Conflict on $sha — retry with -Xtheirs"
                git cherry-pick --abort >/dev/null 2>&1 || true
                if ! git cherry-pick -x -n -Xtheirs "$sha"; then
                  # Still conflicted → report and fail
                  CONFLICTS="$(git diff --name-only --diff-filter=U || true)"
                  git cherry-pick --abort || true
                  echo "::error::Unresolved conflicts on $sha"
                  echo "$CONFLICTS"
                  post_conflict_comment "${SRC_PR_NUM}" "${REL_BRANCH}" "${CONFLICTS}" "${sha}"
                  echo "::endgroup::"
                  exit 1
                fi
              else
                # No U-files → Git says it's empty after resolution → skip this pick
                git cherry-pick --skip || true
                echo "Empty after resolution; treating $sha as already applied. Skipping."
                echo "::endgroup::"
                continue
              fi
            fi

            # Remove workflow changes before committing
            strip_workflows

            # If, after filtering, nothing remains, skip this cherry-pick cleanly
            if skip_if_empty; then
              echo "::endgroup::"
              continue
            fi

            # Commit staged changes with original message (-x trailer already added)
            git commit --no-edit
            echo "::endgroup::"
          done

          # Push after all cherry-picks
          git push origin "HEAD:${REL_BRANCH}"



      # Step 6: Open PR release → main (idempotent)
      - name: Open PR release → main (idempotent)
        id: open_pr
        uses: actions/github-script@v7
        env:
          REL_BRANCH: ${{ steps.build_release.outputs.release_branch }}
          SRC_PR_NUM: ${{ steps.build_release.outputs.pr_number }}
          SRC_PR_TITLE: ${{ steps.build_release.outputs.pr_title }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const branch = (process.env.REL_BRANCH || "").trim();
            if (!branch) { core.setFailed("RELEASE_BRANCH empty"); return; }

            const base = "main";
            const { data: prs } = await github.rest.pulls.list({
              owner, repo, state: "open", head: `${owner}:${branch}`, base, per_page: 1
            });
            if (prs.length > 0) {
              core.setOutput("release_pr_number", prs[0].number.toString());
              core.setOutput("release_pr_url", prs[0].html_url);
              return;
            }

            const title = `[release] Promote PR #${process.env.SRC_PR_NUM} -> main: ${process.env.SRC_PR_TITLE}`;
            const body  = `Automated release PR to promote feature from merged staging PR #${process.env.SRC_PR_NUM}.`;
            const { data: pr } = await github.rest.pulls.create({ owner, repo, head: branch, base, title, body });
            core.setOutput("release_pr_number", pr.number.toString());
            core.setOutput("release_pr_url", pr.html_url);


      - name: Comment on original staging PR about release PR
        if: steps.gen_delta.outputs.no_changes == 'false' && always() && steps.open_pr.outputs.release_pr_number
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RELEASE_PR_URL=${{ steps.open_pr.outputs.release_pr_url }}
          BODY="✅ Automated release PR created: ${RELEASE_PR_URL}"
          gh pr comment "${PR_NUMBER}" --body "$BODY"

  # Mark analyzer as pending on the release PR commit and capture SHA
  code-analyzer-status-pending:
    name: Code Analyzer – mark pending
    needs: [promote-feature-branch, guard-and-context]
    if: ${{ needs.guard-and-context.outputs.is_merge == 'true' && needs.promote-feature-branch.outputs.release_pr_number != '' }}
    runs-on: ubuntu-latest
    outputs:
      analysis_sha: ${{ steps.get.outputs.sha }}
      pr_number: ${{ steps.get.outputs.pr }}
    steps:
      - name: Resolve PR + head SHA (no local git needed)
        id: get
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR: ${{ needs.promote-feature-branch.outputs.release_pr_number }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail

          if [ -z "${PR:-}" ] || ! [[ "$PR" =~ ^[0-9]+$ ]]; then
            echo "::error::Invalid PR number: '${PR:-<empty>}'"
            exit 1
          fi

          # Use GitHub API via gh (explicit repo) to avoid .git dependency
          SHA="$(gh api "repos/${REPO}/pulls/${PR}" --jq '.head.sha')"
          if [ -z "${SHA:-}" ] || [ "${SHA}" = "null" ]; then
            echo "::error::Could not resolve head SHA for PR #${PR}"
            exit 1
          fi

          echo "sha=${SHA}" >> "$GITHUB_OUTPUT"
          echo "pr=${PR}"   >> "$GITHUB_OUTPUT"


      - name: Set commit status pending (code-analyzer)
        env:
          SHA: ${{ steps.get.outputs.sha }}
        run: |
          curl -s -X POST \
            -H "Authorization: Bearer ${{ github.token }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/statuses/${SHA}" \
            -d @- <<JSON
          {
            "state": "pending",
            "context": "code-analyzer",
            "description": "Running Salesforce Code Analyzer",
            "target_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          JSON

  # Reuse your analyzer (unchanged)
  run-code-analyzer:
    needs: [promote-feature-branch, guard-and-context, code-analyzer-status-pending]
    if: ${{ needs.guard-and-context.outputs.is_merge == 'true' }}
    uses: ./.github/workflows/code-analyzer.yml
    permissions:
      actions: read
      pull-requests: write
      contents: read
    with:
      ref: ${{ needs.promote-feature-branch.outputs.release_branch }}
      pr_number: ${{ needs.guard-and-context.outputs.pr_number }}

  # Optionally run your manifest/validation reusable workflow after creating PR
  run-new-pr-to-main:
    needs: [promote-feature-branch, guard-and-context]
    if: ${{ needs.guard-and-context.outputs.is_merge == 'true' }}
    uses: ./.github/workflows/new-main-pr.yml
    permissions:
      contents: write
      pull-requests: write
    with:
      ref: ${{ needs.guard-and-context.outputs.pr_head_ref }}
      pr_number: ${{ needs.guard-and-context.outputs.pr_number }}

  # Flip analyzer status to success/failure and point at analyzer’s own PR comment if present
  code-analyzer-status-final:
    name: Code Analyzer - finalize
    needs: [code-analyzer-status-pending, run-code-analyzer]
    if: ${{ needs.code-analyzer-status-pending.outputs.analysis_sha != '' }}
    runs-on: ubuntu-latest
    steps:
      - name: Decide final state from reusable job result
        id: decide
        run: |
          RES='${{ needs.run-code-analyzer.result }}'   # success | failure | cancelled
          if [ "$RES" = "success" ]; then
            echo "state=success" >> $GITHUB_OUTPUT
            echo "desc=Code Analyzer passed" >> $GITHUB_OUTPUT
          else
            echo "state=failure" >> $GITHUB_OUTPUT
            echo "desc=Code Analyzer failed (${RES})" >> $GITHUB_OUTPUT
          fi

      - name: Find analyzer PR comment URL (no Actions lookup, robust pagination)
        id: find_comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PR:   ${{ needs.code-analyzer-status-pending.outputs.pr_number }}
        run: |
          set -euo pipefail

          # 1) Fetch *all* issue comments and review comments for this PR (no 'since' param)
          ISSUE_JSON="$(gh api "repos/${REPO}/issues/${PR}/comments" --paginate || true)"
          REVIEW_JSON="$(gh api "repos/${REPO}/pulls/${PR}/comments"  --paginate || true)"

          # 2) Combine paginated arrays and pick the most recent github-actions[bot] comment, if any
          ISSUE_URL="$(printf '%s\n' "$ISSUE_JSON" \
            | jq -s -r '[ .[] | .[] | select(.user.login=="github-actions[bot]") ]
                        | sort_by(.created_at) | last | .html_url // empty')"

          REVIEW_URL="$(printf '%s\n' "$REVIEW_JSON" \
            | jq -s -r '[ .[] | .[] | select(.user.login=="github-actions[bot]") ]
                        | sort_by(.created_at) | last | .html_url // empty')"

          if [ -n "${ISSUE_URL:-}" ]; then
            URL="$ISSUE_URL"
          elif [ -n "${REVIEW_URL:-}" ]; then
            URL="$REVIEW_URL"
          else
            # Fallback: point to the PR if no bot comment is found
            URL="${{ github.server_url }}/${{ github.repository }}/pull/${PR}"
          fi

          echo "url=$URL" >> "$GITHUB_OUTPUT"


      - name: Set commit status success/failure (code-analyzer)
        env:
          SHA:   ${{ needs.code-analyzer-status-pending.outputs.analysis_sha }}
          STATE: ${{ steps.decide.outputs.state }}
          DESC:  ${{ steps.decide.outputs.desc }}
          URL:   ${{ steps.find_comment.outputs.url }}
        run: |
          TARGET="${URL:-${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}}"
          curl -s -X POST \
            -H "Authorization: Bearer ${{ github.token }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/statuses/${SHA}" \
            -d @- <<JSON
          {
            "state": "${STATE}",
            "context": "code-analyzer",
            "description": "${DESC}",
            "target_url": "${TARGET}"
          }
          JSON