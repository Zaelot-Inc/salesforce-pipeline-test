name: Build release branch (on PR merged to staging)

on:
  push:
    branches: [staging]

# Ensure only one promotion runs at a time
concurrency:
  group: promote-to-release
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  # Discover the PR that caused this push to 'staging' and ensure it was merged
  guard-and-context:
    name: Resolve PR for this push (must be a merged PR → staging)
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.find.outputs.pr_number }}
      pr_title:  ${{ steps.find.outputs.pr_title }}
      is_merge:  ${{ steps.find.outputs.is_merge }}
      pr_head_ref:   ${{ steps.find.outputs.pr_head_ref }}
      pr_head_sha:   ${{ steps.find.outputs.pr_head_sha }}
      pr_head_owner: ${{ steps.find.outputs.pr_head_owner }}
      pr_head_repo:  ${{ steps.find.outputs.pr_head_repo }}
    steps:
      - name: Find PR associated with this commit
        id: find
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const sha = context.sha;

            // Find PRs tied to this pushed commit
            const prsResp = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner, repo, commit_sha: sha
            });
            // Keep only PRs whose base is 'staging'
            const prs = (prsResp.data || []).filter(pr => pr.base?.ref === 'staging');

            if (!prs.length) {
              core.info('No PR associated with this push to staging. Skipping.');
              core.setOutput('is_merge', 'false');
              return;
            }

            // Take the most recently updated PR and fetch full data to get 'merged' + head info
            const pr = prs.sort((a,b)=> new Date(b.updated_at) - new Date(a.updated_at))[0];
            const prFull = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
            const merged = !!prFull.data.merged;

            core.setOutput('pr_number', String(pr.number));
            core.setOutput('pr_title',  pr.title || '');
            core.setOutput('is_merge',  merged ? 'true' : 'false');

            const head = prFull.data.head || {};
            core.setOutput('pr_head_ref',   head.ref   || '');
            core.setOutput('pr_head_sha',   head.sha   || '');
            core.setOutput('pr_head_owner', head.repo?.owner?.login || '');
            core.setOutput('pr_head_repo',  head.repo?.name || '');

            if (!merged) core.info(`PR #${pr.number} is closed but not merged; skipping.`);

  promote-feature-branch:
    name: Promote feature branch -> release branch
    needs: [guard-and-context]
    if: ${{ needs.guard-and-context.outputs.is_merge == 'true' }}
    runs-on: ubuntu-latest
    env:
      # Example login URL used elsewhere in your pipeline
      SF_LOGIN_URL_PROD: "https://test.salesforce.com"

      # PR context from guard job
      PR_NUMBER:     ${{ needs.guard-and-context.outputs.pr_number }}
      PR_TITLE:      ${{ needs.guard-and-context.outputs.pr_title }}
      PR_HEAD_REF:   ${{ needs.guard-and-context.outputs.pr_head_ref }}
      PR_HEAD_SHA:   ${{ needs.guard-and-context.outputs.pr_head_sha }}
      PR_HEAD_OWNER: ${{ needs.guard-and-context.outputs.pr_head_owner }}
      PR_HEAD_REPO:  ${{ needs.guard-and-context.outputs.pr_head_repo }}
    outputs:
      release_branch: ${{ steps.create_branch.outputs.release_branch }}
      release_pr_number: ${{ steps.open_pr.outputs.release_pr_number }}
    steps:
      # Step 1: Checkout
      - name: Checkout full repo
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false

      # Step 2: Tooling
      - name: Install requirements (sf CLI, sgd, jq, gh)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates rsync
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true
          if ! command -v gh >/dev/null 2>&1; then
            (type -p wget >/dev/null || (sudo apt-get update && sudo apt-get install wget -y)) && \
            sudo mkdir -p -m 755 /etc/apt/keyrings && \
            wget -qO- https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg > /dev/null && \
            sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg && \
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null && \
            sudo apt-get update && \
            sudo apt-get install gh -y
          fi

      - name: Ensure Java 11+
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: zulu

       # Step 3: Fetch main and PR head (ensure all commits are available)
      - name: Fetch main and PR head (for cherry-pick)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git"
          git fetch --no-tags origin +refs/heads/main:refs/remotes/origin/main
          OWNER="${PR_HEAD_OWNER}"; REPO="${PR_HEAD_REPO}"; BR="${PR_HEAD_REF}"; PR="${PR_NUMBER}"
          if [ "${OWNER}/${REPO}" = "${{ github.repository }}" ]; then
            git fetch --no-tags origin "refs/pull/${PR}/head:refs/remotes/pr/${BR}"
          else
            git remote remove fork 2>/dev/null || true
            git remote add fork "https://x-access-token:${GH_TOKEN}@github.com/${OWNER}/${REPO}.git"
            git fetch --no-tags fork "refs/heads/${BR}:refs/remotes/pr/${BR}" || \
            git fetch --no-tags origin "refs/pull/${PR}/head:refs/remotes/pr/${BR}"
          fi
      # Step 4: Compute delta (AM + D) between main and feature
      - name: Generate delta (adds/mods + deletions) for force-app/**
        id: gen_delta
        run: |
          set -euo pipefail
          TO_REF="${FETCH_REF:-${PR_HEAD_SHA}}"
          echo "Generating delta: origin/main -> ${TO_REF}"
          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to "${TO_REF}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          has_addmods="false"
          has_deletions="false"
          
          [ -d changed-sources/force-app ] && [ -n "$(ls -A changed-sources/force-app || true)" ] && has_addmods="true"
          
          echo "Checking for destructive changes..."

          if [ -f changed-sources/destructiveChanges/destructiveChanges.xml ]; then
            echo "Found destructiveChanges.xml, checking for <members>..."
            if grep -q "<members>" changed-sources/destructiveChanges/destructiveChanges.xml; then
              echo "Found <members> in destructiveChanges.xml."
              has_deletions="true"
            else
              echo "File is empty or contains no <members>."
            fi
          fi
          
          if [ -f changed-sources/destructiveChangesPost/destructiveChanges.xml ]; then
            echo "Found destructiveChangesPost.xml, checking for <members>..."
            if grep -q "<members>" changed-sources/destructiveChangesPost/destructiveChanges.xml; then
              echo "Found <members> in destructiveChangesPost.xml."
              has_deletions="true"
            else
              echo "File is empty or contains no <members>."
            fi
          fi

          echo "has_addmods=${has_addmods}"     >> "$GITHUB_OUTPUT"
          echo "has_deletions=${has_deletions}" >> "$GITHUB_OUTPUT"

          if [ "${has_addmods}" != "true" ] && [ "${has_deletions}" != "true" ]; then
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
          else
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Abort if no metadata changes
        if: steps.gen_delta.outputs.no_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BODY="✅ No deployable metadata detected between \`main\` and feature branch \`${PR_HEAD_REF}\` (PR #${PR_NUMBER}). Nothing to promote."
          gh pr comment "${PR_NUMBER}" --body "$BODY"

      # Step 5: Cherry-pick PR commits (preserve history)
      - name: Cherry-pick PR commits (preserve history)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Get PR commits (oldest → newest)
          mapfile -t COMMITS < <(gh api \
            repos/${{ github.repository }}/pulls/${PR_NUMBER}/commits \
            --paginate --jq '.[].sha')
          if [ "${#COMMITS[@]}" -eq 0 ]; then
            echo "No commits found for PR #${PR_NUMBER}"; exit 1
          fi
          git checkout "${RELEASE_BRANCH}"
          for sha in "${COMMITS[@]}"; do
            if git merge-base --is-ancestor "$sha" origin/main; then
              echo "Skip $sha (already in main)"
              continue
            fi
            echo "Cherry-pick $sha"
            git cherry-pick -x "$sha" || { echo "::error::Conflict on $sha"; git cherry-pick --abort; exit 1; }
          done
          git push origin "HEAD:${RELEASE_BRANCH}"

          echo "RELEASE_BRANCH=${RELEASE_BRANCH}" >> $GITHUB_ENV
          echo "release_branch=${RELEASE_BRANCH}" >> $GITHUB_OUTPUT

      # Step 6: Apply changes + generate manifests
      - name: Apply feature changes to release branch + generate manifests (adds/mods/deletes only)
        if: steps.gen_delta.outputs.no_changes == 'false'
        run: |
          set -euo pipefail

          # Identify ourselves for the commit
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global user.name  "github-actions[bot]"

          # Feature ref (from Step 5), fallback to head SHA (from Step 2)
          TO_REF="${FETCH_REF:-${PR_HEAD_SHA}}"

          # -------- A) Bring in adds/edits; remove deletions --------
          # NOTE: If you kept '--find-renames' elsewhere, either remove it (treat as add+delete)
          # or extend filters to include 'R'. This variant treats renames as add+delete.
          while IFS= read -r path; do
            [ -n "$path" ] || continue
            git checkout "$TO_REF" -- "$path"
          done < <(git diff --name-only --diff-filter=AM origin/main "$TO_REF" -- "force-app/**")

          while IFS= read -r path; do
            [ -n "$path" ] || continue
            git rm -f -- "$path" || true
          done < <(git diff --name-only --diff-filter=D origin/main "$TO_REF" -- "force-app/**")

          # -------- B) Create branch-scoped manifest(s) --------
          # Build safe file name from the original branch (Step 2: PR_HEAD_REF)
          BRANCH_RAW="${PR_HEAD_REF}"
          # Replace anything non [A-Za-z0-9._-] with '-'
          BRANCH_SAFE="$(printf "%s" "$BRANCH_RAW" | sed -E 's/[^A-Za-z0-9._-]+/-/g')"

          mkdir -p manifest/branches

          # 1) Regular package manifest: manifest/branches/{branch}Package.xml
          PKG_PATH="manifest/branches/${BRANCH_SAFE}Package.xml"
          if [ -f "changed-sources/package/package.xml" ]; then
            # Use the package generated in Step 6’s delta for exact adds/edits
            cp "changed-sources/package/package.xml" "$PKG_PATH"
          else
            # Delta can be deletion-only; synthesize a minimal, valid package.xml for audit
            API_VER="$(jq -r '.sourceApiVersion // empty' sfdx-project.json 2>/dev/null || true)"
            API_VER="${API_VER:-60.0}"
            echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
            <Package xmlns=\"http://soap.sforce.com/2006/04/metadata\">
              <version>${API_VER}</version>
            </Package>" > "$PKG_PATH"
          fi

          # 2) Destructive manifest (if necessary)
          PRE_XML="changed-sources/destructiveChanges/destructiveChanges.xml"
          POST_XML="changed-sources/destructiveChangesPost/destructiveChanges.xml"
          if [ "${{ steps.gen_delta.outputs.has_deletions }}" = "true" ]; then
            DEST_PATH="manifest/branches/${BRANCH_SAFE}Package-destructive.xml"
            echo "Found destructive members, generating merged destructive manifest..."
            export DEST_PATH
            python3 .github/scripts/merge_destructive.py
          fi


          # -------- C) Stage only metadata + the new manifests (avoid changed-sources/) --------
          git add -A -- "force-app" "manifest/branches"

          # -------- D) Commit only if there are changes --------
          if git diff --cached --quiet; then
            echo "Release creation aborted: no changes to commit."
            exit 0
          fi

          git commit -m "release: promote PR #${PR_NUMBER} (${PR_HEAD_REF} -> main) [automated]"
          git push origin "HEAD:${RELEASE_BRANCH}"

      # Step 7: Open PR release → main (idempotent)
      - name: Open PR from release branch into main
        if: steps.gen_delta.outputs.no_changes == 'false'
        id: open_pr
        uses: actions/github-script@v7
        env:
          REL_BRANCH: ${{ env.RELEASE_BRANCH }}
        with:
          script: |
            // Helper poll
            const poll = async (fn, { interval, timeout }) => {
              const start = Date.now();
              while (true) {
                try { return await fn(); }
                catch (e) {
                  if (Date.now() - start > timeout) throw e;
                  core.info(`Check for branch failed, retrying in ${interval}ms...`);
                  await new Promise(r => setTimeout(r, interval));
                }
              }
            };

            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const branch = (process.env.REL_BRANCH || "").trim();

            if (!branch) {
              core.setFailed("RELEASE_BRANCH is empty or not set.");
              return;
            }

            // Ensure remote branch exists
            try {
              await poll(
                () => github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` }),
                { interval: 5000, timeout: 30000 }
              );
              core.info(`Found remote branch 'heads/${branch}'.`);
            } catch (e) {
              core.setFailed(`Remote branch 'heads/${branch}' not found. ${e.message}`);
              return;
            }

            // Reuse if exists
            const base = "main";
            const { data: prs } = await github.rest.pulls.list({
              owner, repo, state: "open", head: `${owner}:${branch}`, base, per_page: 1
            });
            if (prs.length > 0) {
              core.info(`Release PR already exists: #${prs[0].number}`);
              core.setOutput("release_pr_number", prs[0].number.toString());
              core.setOutput("release_pr_url", prs[0].html_url);
              return;
            }

            // Create the PR
            const title = `[release] Promote PR #${process.env.PR_NUMBER} -> main: ${process.env.PR_TITLE}`;
            const body  = `Automated release PR to promote feature from staging PR #${process.env.PR_NUMBER}.`;
            const { data: pr } = await github.rest.pulls.create({ owner, repo, head: branch, base, title, body });
            core.setOutput("release_pr_number", pr.number.toString());
            core.setOutput("release_pr_url", pr.html_url);
            core.info(`Created release PR #${pr.number}`);

      - name: Comment on original staging PR about release PR
        if: steps.gen_delta.outputs.no_changes == 'false' && always() && steps.open_pr.outputs.release_pr_number
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RELEASE_PR_URL=${{ steps.open_pr.outputs.release_pr_url }}
          BODY="✅ Automated release PR created: ${RELEASE_PR_URL}"
          gh pr comment "${PR_NUMBER}" --body "$BODY"

  # Mark analyzer as pending on the release PR commit and capture SHA
  code-analyzer-status-pending:
    name: Code Analyzer – mark pending
    needs: [promote-feature-branch, guard-and-context]
    if: ${{ needs.guard-and-context.outputs.is_merge == 'true' && needs.promote-feature-branch.outputs.release_pr_number != '' }}
    runs-on: ubuntu-latest
    outputs:
      analysis_sha: ${{ steps.get.outputs.sha }}
      pr_number: ${{ steps.get.outputs.pr }}
    steps:
      - name: Resolve PR + head SHA
        id: get
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR: ${{ needs.promote-feature-branch.outputs.release_pr_number }}
        run: |
          set -euo pipefail
          SHA=$(gh pr view "$PR" --json headRefOid --jq .headRefOid)
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "pr=$PR"   >> "$GITHUB_OUTPUT"

      - name: Set commit status pending (code-analyzer)
        env:
          SHA: ${{ steps.get.outputs.sha }}
        run: |
          curl -s -X POST \
            -H "Authorization: Bearer ${{ github.token }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/statuses/${SHA}" \
            -d @- <<JSON
          {
            "state": "pending",
            "context": "code-analyzer",
            "description": "Running Salesforce Code Analyzer",
            "target_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          JSON

  # Reuse your analyzer (unchanged)
  run-code-analyzer:
    needs: [promote-feature-branch, guard-and-context, code-analyzer-status-pending]
    if: ${{ needs.guard-and-context.outputs.is_merge == 'true' }}
    uses: ./.github/workflows/code-analyzer.yml
    permissions:
      actions: read
      pull-requests: write
      contents: read
    with:
      ref: ${{ needs.promote-feature-branch.outputs.release_branch }}

  # Optionally run your manifest/validation reusable workflow after creating PR
  run-new-pr-to-main:
    needs: [promote-feature-branch, guard-and-context]
    if: ${{ needs.guard-and-context.outputs.is_merge == 'true' }}
    uses: ./.github/workflows/new-main-pr.yml
    permissions:
      contents: write
      pull-requests: write
    with:
      ref: ${{ needs.promote-feature-branch.outputs.release_branch }}

  # Flip analyzer status to success/failure and point at analyzer’s own PR comment if present
  code-analyzer-status-final:
    name: Code Analyzer - finalize
    needs: [code-analyzer-status-pending, run-code-analyzer]
    if: ${{ needs.code-analyzer-status-pending.outputs.analysis_sha != '' }}
    runs-on: ubuntu-latest
    steps:
      - name: Decide final state from reusable job result
        id: decide
        run: |
          RES='${{ needs.run-code-analyzer.result }}'   # success | failure | cancelled
          if [ "$RES" = "success" ]; then
            echo "state=success" >> $GITHUB_OUTPUT
            echo "desc=Code Analyzer passed" >> $GITHUB_OUTPUT
          else
            echo "state=failure" >> $GITHUB_OUTPUT
            echo "desc=Code Analyzer failed (${RES})" >> $GITHUB_OUTPUT
          fi

      - name: Find analyzer PR comment URL (robust)
        id: find_comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PR: ${{ needs.code-analyzer-status-pending.outputs.pr_number }}
          SHA: ${{ needs.code-analyzer-status-pending.outputs.analysis_sha }}
        run: |
          set -euo pipefail

          # 1) Find the analyzer workflow run for this SHA (event=workflow_call)
          RUN_JSON=$(gh api \
            repos/$REPO/actions/workflows/code-analyzer.yml/runs \
            -f head_sha="$SHA" -f event=workflow_call \
            --jq '.workflow_runs | sort_by(.created_at) | last // empty')

          if [ -n "$RUN_JSON" ] && [ "$RUN_JSON" != "null" ]; then
            RUN_ID=$(jq -r '.id' <<<"$RUN_JSON")
            RUN_CREATED=$(jq -r '.created_at' <<<"$RUN_JSON")
            RUN_URL=$(jq -r '.html_url' <<<"$RUN_JSON")
          else
            RUN_ID=""
            RUN_CREATED=$(date -u -d "1 day ago" +"%Y-%m-%dT%H:%M:%SZ")
            RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          fi

          # 2) Collect PR comments since the run started (issue + review)
          ISSUE_COMMENTS=$(gh api repos/$REPO/issues/$PR/comments -f since="$RUN_CREATED" --paginate)
          REVIEW_COMMENTS=$(gh api repos/$REPO/pulls/$PR/comments -f since="$RUN_CREATED" --paginate)

          # 3) Filter to bot comments (most analyzers comment as github-actions[bot])
          BOT="github-actions[bot]"
          ISSUE_URL=$(jq -r --arg BOT "$BOT" \
            '[ .[] | select(.user.login == $BOT) ] | sort_by(.created_at) | last | .html_url // empty' \
            <<<"$ISSUE_COMMENTS")
          REVIEW_URL=$(jq -r --arg BOT "$BOT" \
            '[ .[] | select(.user.login == $BOT) ] | sort_by(.created_at) | last | .html_url // empty' \
            <<<"$REVIEW_COMMENTS")

          if [ -n "$ISSUE_URL" ]; then
            URL="$ISSUE_URL"
          elif [ -n "$REVIEW_URL" ]; then
            URL="$REVIEW_URL"
          else
            URL="$RUN_URL"
          fi

          echo "url=$URL" >> "$GITHUB_OUTPUT"

      - name: Set commit status success/failure (code-analyzer)
        env:
          SHA:   ${{ needs.code-analyzer-status-pending.outputs.analysis_sha }}
          STATE: ${{ steps.decide.outputs.state }}
          DESC:  ${{ steps.decide.outputs.desc }}
          URL:   ${{ steps.find_comment.outputs.url }}
        run: |
          TARGET="${URL:-${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}}"
          curl -s -X POST \
            -H "Authorization: Bearer ${{ github.token }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/statuses/${SHA}" \
            -d @- <<JSON
          {
            "state": "${STATE}",
            "context": "code-analyzer",
            "description": "${DESC}",
            "target_url": "${TARGET}"
          }
          JSON
