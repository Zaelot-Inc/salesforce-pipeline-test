name: Build release branch (on PR merged to staging)
'on':
  pull_request:
    types:
      - closed
    branches:
      - staging
concurrency:
  group: promote-to-release
  cancel-in-progress: false
permissions:
  contents: write
  pull-requests: write
jobs:
  promote-feature-branch:
    name: Promote feature branch -> release branch
    runs-on: ubuntu-latest
    if: >-
      ${{ github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'staging' }}
    env:
      SF_LOGIN_URL_PROD: 'https://test.salesforce.com'
    outputs:
      release_branch: '${{ steps.create_branch.outputs.release_branch }}'
      release_pr_number: '${{ steps.open_pr.outputs.release_pr_number }}'
    steps:
      - name: Checkout full repo
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false
      - name: Set PR context variables
        id: prinfo
        run: >
          echo "PR_NUMBER=${{ github.event.pull_request.number }}" >>
          $GITHUB_ENV

          echo "PR_TITLE<<EOF" >> $GITHUB_ENV

          echo "${{ github.event.pull_request.title }}" >> $GITHUB_ENV

          echo "EOF" >> $GITHUB_ENV

          echo "PR_HEAD_REF=${{ github.event.pull_request.head.ref }}" >>
          $GITHUB_ENV

          echo "PR_HEAD_SHA=${{ github.event.pull_request.head.sha }}" >>
          $GITHUB_ENV

          echo "PR_HEAD_OWNER=${{
          github.event.pull_request.head.repo.owner.login }}" >> $GITHUB_ENV

          echo "PR_HEAD_REPO=${{ github.event.pull_request.head.repo.name }}" >>
          $GITHUB_ENV
      - name: 'Install requirements (sf CLI, sfdx-git-delta, jq, gh)'
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates rsync
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true
          # Install GitHub CLI
          if ! command -v gh >/dev/null 2>&1; then
            (type -p wget >/dev/null || (sudo apt-get update && sudo apt-get install wget -y)) && \
            sudo mkdir -p -m 755 /etc/apt/keyrings && \
            wget -qO- https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg > /dev/null && \
            sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg && \
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null && \
            sudo apt-get update && \
            sudo apt-get install gh -y
          fi
      - name: Ensure Java 11+
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: zulu
      - name: Fetch origin/main and prepare refs
        run: >
          set -euo pipefail

          git remote set-url origin "https://x-access-token:${{
          secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"

          git fetch --no-tags origin main:refs/remotes/origin/main

          git rev-parse --verify origin/main
      - name: Fetch feature branch (supports forks)
        id: fetch_feature
        env:
          GH_TOKEN: '${{ secrets.GITHUB_TOKEN }}'
        run: |
          set -eo pipefail
          OWNER="${PR_HEAD_OWNER}"
          REPONAME="${PR_HEAD_REPO}"
          BRANCH="${PR_HEAD_REF}"
          PR_NUM="${PR_NUMBER}"
          echo "Fetching '${BRANCH}' from ${OWNER}/${REPONAME} ..."

          if [ "${OWNER}/${REPONAME}" = "${{ github.repository }}" ]; then
            if git fetch origin "refs/pull/${PR_NUM}/head:refs/remotes/pr/${BRANCH}" 2>/dev/null; then
              echo "FETCH_REF=refs/remotes/pr/${BRANCH}" >> $GITHUB_ENV
            elif git fetch origin "${BRANCH}:refs/remotes/pr/${BRANCH}" 2>/dev/null; then
              echo "FETCH_REF=refs/remotes/pr/${BRANCH}" >> $GITHUB_ENV
            else
              echo "Could not fetch feature branch by ref from origin; falling back to PR head SHA ${PR_HEAD_SHA}"
              echo "FETCH_REF=${PR_HEAD_SHA}" >> $GITHUB_ENV
            fi
          else
            git remote remove fork 2>/dev/null || true
            git remote add fork "https://x-access-token:${GH_TOKEN}@github.com/${OWNER}/${REPONAME}.git"
            if git fetch fork "${BRANCH}:refs/remotes/pr/${BRANCH}" 2>/dev/null; then
              echo "FETCH_REF=refs/remotes/pr/${BRANCH}" >> $GITHUB_ENV
            else
              echo "Could not fetch from fork by branch; falling back to PR head SHA ${PR_HEAD_SHA}"
              echo "FETCH_REF=${PR_HEAD_SHA}" >> $GITHUB_ENV
            fi
          fi

          echo "Fetch reference: ${FETCH_REF:-(not set)}"
      - name: Generate metadata delta (origin/main -> feature)
        id: gen_delta
        run: >
          set -euo pipefail

          TO_REF="${FETCH_REF:-${PR_HEAD_SHA}}"

          echo "Generating delta: origin/main -> ${TO_REF}"

          mkdir -p changed-sources

          sf sgd source delta \
            --from "origin/main" \
            --to "${TO_REF}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          has_addmods="false"

          has_deletions="false"


          [ -d changed-sources/force-app ] && [ -n "$(ls -A
          changed-sources/force-app || true)" ] && has_addmods="true"


          echo "Checking for destructive changes..."


          if [ -f changed-sources/destructiveChanges/destructiveChanges.xml ];
          then
            echo "Found destructiveChanges.xml, checking for <members>..."
            if grep -q "<members>" changed-sources/destructiveChanges/destructiveChanges.xml; then
              echo "Found <members> in destructiveChanges.xml."
              has_deletions="true"
            else
              echo "File is empty or contains no <members>."
            fi
          fi


          if [ -f changed-sources/destructiveChangesPost/destructiveChanges.xml
          ]; then
            echo "Found destructiveChangesPost.xml, checking for <members>..."
            if grep -q "<members>" changed-sources/destructiveChangesPost/destructiveChanges.xml; then
              echo "Found <members> in destructiveChangesPost.xml."
              has_deletions="true"
            else
              echo "File is empty or contains no <members>."
            fi
          fi


          echo "has_addmods=${has_addmods}"     >> "$GITHUB_OUTPUT"

          echo "has_deletions=${has_deletions}" >> "$GITHUB_OUTPUT"


          if [ "${has_addmods}" != "true" ] && [ "${has_deletions}" != "true" ];
          then
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
          else
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
          fi
      - name: Abort if no metadata changes
        if: steps.gen_delta.outputs.no_changes == 'true'
        env:
          GH_TOKEN: '${{ secrets.GITHUB_TOKEN }}'
        run: >
          BODY="✅ No deployable metadata detected between \`main\` and feature
          branch \`${PR_HEAD_REF}\` (PR #${PR_NUMBER}). Nothing to promote."

          gh pr comment "${PR_NUMBER}" --body "$BODY"
      - name: Create release branch from origin/main
        if: steps.gen_delta.outputs.no_changes == 'false'
        id: create_branch
        run: |
          set -euo pipefail
          SHORTSHA=$(echo "${PR_HEAD_SHA}" | cut -c1-7)
          RELEASE_BRANCH="release/pr-${PR_NUMBER}-${SHORTSHA}"
          git checkout -b "${RELEASE_BRANCH}" origin/main
          echo "RELEASE_BRANCH=${RELEASE_BRANCH}" >> $GITHUB_ENV
          echo "release_branch=${RELEASE_BRANCH}" >> $GITHUB_OUTPUT
      - name: >-
          Apply feature changes to release branch + generate manifests
          (adds/mods/deletes only)
        if: steps.gen_delta.outputs.no_changes == 'false'
        run: >
          set -euo pipefail


          # Identify ourselves for the commit

          git config --global user.email
          "41898282+github-actions[bot]@users.noreply.github.com"

          git config --global user.name  "github-actions[bot]"


          # Feature ref (from Step 5), fallback to head SHA (from Step 2)

          TO_REF="${FETCH_REF:-${PR_HEAD_SHA}}"


          # -------- A) Bring in adds/edits; remove deletions --------

          # NOTE: If you kept '--find-renames' elsewhere, either remove it
          (treat as add+delete)

          # or extend filters to include 'R'. This variant treats renames as
          add+delete.

          while IFS= read -r path; do
            [ -n "$path" ] || continue
            git checkout "$TO_REF" -- "$path"
          done < <(git diff --name-only --diff-filter=AM origin/main "$TO_REF"
          -- "force-app/**")


          while IFS= read -r path; do
            [ -n "$path" ] || continue
            git rm -f -- "$path" || true
          done < <(git diff --name-only --diff-filter=D origin/main "$TO_REF" --
          "force-app/**")


          # -------- B) Create branch-scoped manifest(s) --------

          # Build safe file name from the original branch (Step 2: PR_HEAD_REF)

          BRANCH_RAW="${PR_HEAD_REF}"

          # Replace anything non [A-Za-z0-9._-] with '-'

          BRANCH_SAFE="$(printf "%s" "$BRANCH_RAW" | sed -E
          's/[^A-Za-z0-9._-]+/-/g')"


          mkdir -p manifest/branches


          # 1) Regular package manifest: manifest/branches/{branch}Package.xml

          PKG_PATH="manifest/branches/${BRANCH_SAFE}Package.xml"

          if [ -f "changed-sources/package/package.xml" ]; then
            # Use the package generated in Step 6’s delta for exact adds/edits
            cp "changed-sources/package/package.xml" "$PKG_PATH"
          else
            # Delta can be deletion-only; synthesize a minimal, valid package.xml for audit
            API_VER="$(jq -r '.sourceApiVersion // empty' sfdx-project.json 2>/dev/null || true)"
            API_VER="${API_VER:-64.0}"
            echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
            <Package xmlns=\"http://soap.sforce.com/2006/04/metadata\">
              <version>${API_VER}</version>
            </Package>" > "$PKG_PATH"
          fi


          # 2) Destructive manifest (if necessary)

          PRE_XML="changed-sources/destructiveChanges/destructiveChanges.xml"

          POST_XML="changed-sources/destructiveChangesPost/destructiveChanges.xml"

          if [ "${{ steps.gen_delta.outputs.has_deletions }}" = "true" ]; then
            DEST_PATH="manifest/branches/${BRANCH_SAFE}Package-destructive.xml"
            echo "Found destructive members, generating merged destructive manifest..."
            export DEST_PATH
            python3 .github/scripts/merge_destructive.py
          fi



          # -------- C) Stage only metadata + the new manifests (avoid
          changed-sources/) --------

          git add -A -- "force-app" "manifest/branches"


          # -------- D) Commit only if there are changes --------

          if git diff --cached --quiet; then
            echo "Release creation aborted: no changes to commit."
            exit 0
          fi


          git commit -m "release: promote PR #${PR_NUMBER} (${PR_HEAD_REF} ->
          main) [automated]"

          git push origin "HEAD:${RELEASE_BRANCH}"
      - name: Open PR from release branch into main
        if: steps.gen_delta.outputs.no_changes == 'false'
        id: open_pr
        uses: actions/github-script@v7
        env:
          REL_BRANCH: '${{ env.RELEASE_BRANCH }}'
        with:
          script: >
            // Helper function to poll for the branch's existence after the
            push.

            const poll = async (fn, { interval, timeout }) => {
              const start = Date.now();
              while (true) {
                try {
                  return await fn(); // Attempt to resolve the function
                } catch (e) {
                  if (Date.now() - start > timeout) {
                    core.error(`Polling timed out after ${timeout}ms. Last error: ${e.message}`);
                    throw e; // Rerethrow the last error
                  }
                  core.info(`Check for branch failed, retrying in ${interval}ms...`);
                  await new Promise(resolve => setTimeout(resolve, interval));
                }
              }
            };


            const owner = context.repo.owner;

            const repo  = context.repo.repo;

            const branch = (process.env.REL_BRANCH || "").trim();

            if (!branch) {
              core.setFailed("RELEASE_BRANCH is empty or not set.");
              return;
            }


            // Verify the branch exists on the remote using polling

            try {
              await poll(
                () => github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` }),
                { interval: 5000, timeout: 30000 } // Poll every 5s for 30s
              );
              core.info(`Found remote branch 'heads/${branch}' after polling.`);
            } catch (e) {
              core.setFailed(`Remote branch 'heads/${branch}' not found even after polling. Did 'git push' succeed? ${e.message}`);
              return;
            }


            // Reuse an existing open PR if one is found.

            const base = "main";

            const { data: prs } = await github.rest.pulls.list({ owner, repo,
            state: "open", head: `${owner}:${branch}`, base, per_page: 1 });

            if (prs.length > 0) {
              core.info(`Release PR already exists: #${prs[0].number}`);
              core.setOutput("release_pr_number", prs[0].number.toString());
              core.setOutput("release_pr_url", prs[0].html_url);
              return;
            }


            // Create the PR

            const title = `[release] Promote PR #${process.env.PR_NUMBER} ->
            main: ${process.env.PR_TITLE}`;

            const body  = `Automated release PR to promote feature from staging
            PR #${process.env.PR_NUMBER}.`;


            try {
              const { data: pr } = await github.rest.pulls.create({ owner, repo, head: branch, base, title, body });
              core.setOutput("release_pr_number", pr.number.toString());
              core.setOutput("release_pr_url", pr.html_url);
              core.info(`Created release PR #${pr.number}`);
            } catch (e) {
              core.setFailed(`Failed to create release PR: ${e.message}`);
            }
      - name: Comment on original staging PR about release PR
        if: >-
          steps.gen_delta.outputs.no_changes == 'false' && always() &&
          steps.open_pr.outputs.release_pr_number
        env:
          GH_TOKEN: '${{ secrets.GITHUB_TOKEN }}'
        run: |
          RELEASE_PR_URL=${{ steps.open_pr.outputs.release_pr_url }}
          BODY="✅ Automated release PR created: ${RELEASE_PR_URL}"
          gh pr comment "${PR_NUMBER}" --body "$BODY"

          # Run Code Analyzer on the release branch (reusable)
  run-prod-validation:
    needs: promote-feature-branch
    uses: ./.github/workflows/new-main-pr.yml
    permissions:
      contents: write          # we commit manifests into the PR branch (same-repo PRs)
      pull-requests: write
    with:
      ref: '${{ needs.promote-feature-branch.outputs.release_branch }}'
      pr_number: '${{ needs.promote-feature-branch.outputs.release_pr_number || '''' }}'
      pr_title: '${{ github.event.pull_request.title || '''' }}'
  run-code-analyzer:
    needs: promote-feature-branch
    uses: ./.github/workflows/code-analyzer.yml
    permissions:
      pull-requests: write
      contents: read
      actions: read
    with:
      ref: '${{ needs.promote-feature-branch.outputs.release_branch }}'
