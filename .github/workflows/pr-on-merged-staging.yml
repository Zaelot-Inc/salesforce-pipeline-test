name: Build release branch (on PR merged to staging)

on:
  pull_request:
    types: [closed]
    branches: [staging]

permissions:
  contents: write
  pull-requests: write

jobs:
  promote-feature-branch:
    name: Promote feature branch -> release branch (no Prod validation here)
    runs-on: ubuntu-latest
    if: ${{ github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'staging' }}
    env:
      SF_LOGIN_URL_PROD: "https://test.salesforce.com"
    outputs:
      release_branch: ${{ steps.create_branch.outputs.release_branch }}
      release_pr_number: ${{ steps.open_pr.outputs.release_pr_number }}

    steps:
      - name: Checkout full repo
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set PR context variables
        id: prinfo
        run: |
          echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          echo "PR_TITLE<<EOF" >> $GITHUB_ENV
          echo "${{ github.event.pull_request.title }}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "PR_HEAD_REF=${{ github.event.pull_request.head.ref }}" >> $GITHUB_ENV
          echo "PR_HEAD_REPO_FULL=${{ github.event.pull_request.head.repo.full_name }}" >> $GITHUB_ENV
          echo "PR_HEAD_OWNER=${{ github.event.pull_request.head.repo.owner.login }}" >> $GITHUB_ENV
          echo "PR_HEAD_REPO=${{ github.event.pull_request.head.repo.name }}" >> $GITHUB_ENV
          echo "PR_HEAD_SHA=${{ github.event.pull_request.head.sha }}" >> $GITHUB_ENV

      - name: Install requirements (sf CLI, sfdx-git-delta, jq, gh)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true
          if ! command -v gh >/dev/null 2>&1; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
              | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
              && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
              && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
              | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
              && sudo apt update && sudo apt install -y gh
          fi

      - name: Ensure Java 11+
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'zulu'

      - name: Fetch origin/main and prepare refs
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          git fetch --no-tags origin main:refs/remotes/origin/main
          git rev-parse --verify origin/main
          echo "PR #${PR_NUMBER}: head=${PR_HEAD_REF} repo=${PR_HEAD_REPO_FULL} sha=${PR_HEAD_SHA}"

      - name: Fetch feature branch (supports forks)
        id: fetch_feature
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          OWNER="${PR_HEAD_OWNER}"
          REPONAME="${PR_HEAD_REPO}"
          BRANCH="${PR_HEAD_REF}"
          PR_NUM="${PR_NUMBER}"
          echo "Fetching '${BRANCH}' from ${OWNER}/${REPONAME} ..."

          if [ "${OWNER}/${REPONAME}" = "${{ github.repository }}" ]; then
            if ! git fetch origin "refs/heads/${BRANCH}:refs/remotes/pr/${BRANCH}"; then
              echo "Direct fetch failed; trying PR ref fallback..."
              git fetch origin "refs/pull/${PR_NUM}/head:refs/remotes/pr/${BRANCH}"
            fi
          else
            git remote remove fork 2>/dev/null || true
            git remote add fork "https://x-access-token:${GH_TOKEN}@github.com/${OWNER}/${REPONAME}.git"
            if ! git fetch --no-tags fork "refs/heads/${BRANCH}:refs/remotes/pr/${BRANCH}"; then
              echo "Fork fetch failed; trying PR ref fallback..."
              git fetch origin "refs/pull/${PR_NUM}/head:refs/remotes/pr/${BRANCH}"
            fi
          fi

          if git show-ref --verify --quiet "refs/remotes/pr/${BRANCH}"; then
            echo "FETCH_REF=refs/remotes/pr/${BRANCH}" >> $GITHUB_ENV
          else
            echo "Could not fetch branch by name; falling back to PR head SHA ${PR_HEAD_SHA}"
            echo "FETCH_REF=${PR_HEAD_SHA}" >> $GITHUB_ENV
          fi

      # ⬇️ MODIFIED to check for destructive changes as well
      - name: Generate metadata delta (origin/main -> feature) and set integration ref
        id: gen_delta
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail
          # integration (PR merge) ref – useful if you later use it
          if [ -n "${PR_NUMBER:-}" ]; then
            git fetch --no-tags origin "refs/pull/${PR_NUMBER}/merge:refs/remotes/origin/pr-${PR_NUMBER}-merge" || true
            if git show-ref --verify --quiet "refs/remotes/origin/pr-${PR_NUMBER}-merge"; then
              echo "integration_ref=refs/remotes/origin/pr-${PR_NUMBER}-merge" >> "$GITHUB_OUTPUT"
            fi
          fi

          TO_REF="${FETCH_REF:-${PR_HEAD_SHA}}"
          echo "Generating delta: origin/main -> ${TO_REF}"
          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to "${TO_REF}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          # MODIFIED: Check for force-app OR destructive changes
          if [ -n "$(ls -A changed-sources/force-app/ || true)" ] || \
             [ -f "changed-sources/destructiveChanges/destructiveChanges.xml" ] || \
             [ -f "changed-sources/destructiveChangesPost/destructiveChanges.xml" ]; then
            
            find changed-sources -type f | sed 's#^changed-sources/##' > changed-files.txt
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
            echo "changed_files_list=changed-files.txt" >> "$GITHUB_OUTPUT"
          else
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Abort if no metadata changes
        if: steps.gen_delta.outputs.no_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          BODY="No deployable metadata detected between \`main\` and feature branch \`${PR_HEAD_REF}\` (PR #${PR_NUMBER}). Nothing to promote."
          gh pr comment "${PR_NUMBER}" --body "$BODY" || true
          exit 0

      - name: Conflict check vs main (merge-base & delta intersection)
        id: conflict_check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          FEATURE_REF="${FETCH_REF}"
          MERGE_BASE=$(git merge-base origin/main "${FEATURE_REF}")
          git diff --name-only "${MERGE_BASE}" origin/main > files_changed_on_main_since_base.txt
          # MODIFIED: Check against changed-files.txt (which now includes non-force-app files)
          if [ -s changed-files.txt ] && [ -s files_changed_on_main_since_base.txt ] && \
             grep -xF -f changed-files.txt files_changed_on_main_since_base.txt >/dev/null 2>&1; then
            BODY="⛔ *Promotion blocked*: Files changed on \`main\` since this branch diverged also appear in the feature delta. Please rebase/merge main into the feature and retry."
            gh pr comment "${PR_NUMBER}" --body "$BODY" || true
            exit 1
          fi
          echo "No conflicting changes on main detected."

      - name: Create release branch from origin/main
        id: create_branch
        run: |
          set -euo pipefail
          SHORTSHA=$(echo "${PR_HEAD_SHA}" | cut -c1-7)
          RELEASE_BRANCH="release/pr-${PR_NUMBER}-${SHORTSHA}"
          git checkout -b "${RELEASE_BRANCH}" origin/main
          echo "RELEASE_BRANCH=${RELEASE_BRANCH}" >> $GITHUB_ENV
          echo "release_branch=${RELEASE_BRANCH}" >> $GITHUB_OUTPUT

      # ⬇️ MODIFIED to copy entire delta and add all files
      - name: Copy delta into release branch and commit
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git config --global user.email "augusto@zaelot.com"
          git config --global user.name "Augusto Presotto"
          
          echo "Copying all delta files..."
          # Copy EVERYTHING from changed-sources (force-app, destructiveChanges, etc.)
          # Use 'dot-glob' to ensure hidden files (if any) are copied
          shopt -s dotglob
          rsync -av --delete changed-sources/ ./
          shopt -u dotglob

          # Add ALL changes (force-app, destructiveChanges, etc.)
          git add -A .
          
          if git diff --cached --quiet; then
            gh pr comment "${PR_NUMBER}" --body "Release creation aborted: no changes to commit on release branch for PR #${PR_NUMBER}." || true
            exit 0
          fi
          
          git commit -m "release: promote PR #${PR_NUMBER} (${PR_HEAD_REF} -> main) [automated]"
          git push origin "HEAD:${RELEASE_BRANCH}"

      - name: Open PR from release branch into main
        id: open_pr
        uses: actions/github-script@v7
        env:
          REL_BRANCH: ${{ env.RELEASE_BRANCH }}
        with:
          script: |
            // Helper function to poll for the branch
            const poll = async (fn, { interval, timeout }) => {
              const start = Date.now();
              while (true) {
                try {
                  return await fn(); // Attempt to resolve the function
                } catch (e) {
                  if (Date.now() - start > timeout) {
                    core.error(`Polling timed out after ${timeout}ms. Last error: ${e.message}`);
                    throw e; // Rerethrow the last error
                  }
                  core.info(`Check for branch failed, retrying in ${interval}ms...`);
                  await new Promise(resolve => setTimeout(resolve, interval));
                }
              }
            };

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Normalize the branch (strip any refs/ prefix if present)
            const raw = (process.env.REL_BRANCH || "").trim();
            const branch = raw.replace(/^refs\/heads\//, "").replace(/^refs\/remotes\/origin\//, "");
            if (!branch) {
              core.setFailed("RELEASE_BRANCH is empty or not set.");
              return;
            }

            // Verify the branch exists on the remote using polling
            try {
              await poll(
                () => github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` }),
                { interval: 5000, timeout: 30000 } // Poll every 5s for 30s
              );
              core.info(`Found remote branch 'heads/${branch}' after polling.`);
            } catch (e) {
              core.setFailed(`Remote branch 'heads/${branch}' not found even after polling. Did 'git push' succeed? ${e.message}`);
              return;
            }

            // If an open PR from this branch to main already exists, reuse it
            const base = "main";
            const { data: prs } = await github.rest.pulls.list({
              owner, repo, state: "open", head: `${owner}:${branch}`, base, per_page: 100
            });
            const existing = prs.find(p => p.head?.ref === branch && p.base?.ref === base);
            if (existing) {
              core.info(`Release PR already exists: #${existing.number}`);
              core.setOutput("release_pr_number", existing.number.toString());
              core.setOutput("release_pr_url", existing.html_url);
              return;
            }

            // Create the PR
            const title = `[release] Promote PR #${process.env.PR_NUMBER} -> main: ${process.env.PR_TITLE}`;
            const body  = `Automated release PR to promote feature from staging PR #${process.env.PR_NUMBER}.`;

            try {
              const { data: pr } = await github.rest.pulls.create({
                owner, repo,
                head: branch,
                base,
                title, body,
                maintainer_can_modify: true
              });
              core.setOutput("release_pr_number", pr.number.toString());
              core.setOutput("release_pr_url", pr.html_url);
              core.info(`Created release PR #${pr.number}`);
            } catch (e)
              core.setFailed(
                `Failed to create release PR: ${e.message}\n` +
                `Diagnostics:\n- repo: ${owner}/${repo}\n- head: ${branch}\n- base: ${base}`
              );
            }

      - name: Comment original staging PR about release PR
        run: |
          RELEASE_PR_NUMBER=${{ steps.open_pr.outputs.release_pr_number }}
          RELEASE_PR_URL=${{ steps.open_pr.outputs.release_pr_url }}
          BODY="✅ Automated release PR created: #${RELEASE_PR_NUMBER} (${RELEASE_PR_URL})."
          gh pr comment "${PR_NUMBER}" --body "$BODY" || true