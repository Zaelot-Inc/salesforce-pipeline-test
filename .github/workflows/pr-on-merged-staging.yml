name: Build release branch + validate Prod (on PR merged to staging)

on:
  pull_request:
    types: [closed]
    branches: [staging]

permissions:
  contents: write
  pull-requests: write
  checks: write

jobs:
  promote-feature-branch:
    name: Promote feature branch -> release branch & validate to Prod
    runs-on: ubuntu-latest
    if: ${{ github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'staging' }}
    env:
      SF_LOGIN_URL_PROD: "https://test.salesforce.com"
    outputs:
      release_branch: ${{ steps.create_branch.outputs.release_branch }}
      release_pr_number: ${{ steps.open_pr.outputs.release_pr_number }}
    steps:
      - name: Checkout full repo
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set PR context variables
        id: prinfo
        run: |
          echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          echo "PR_TITLE<<EOF" >> $GITHUB_ENV
          echo "${{ github.event.pull_request.title }}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "PR_HEAD_REF=${{ github.event.pull_request.head.ref }}" >> $GITHUB_ENV
          echo "PR_HEAD_REPO_FULL=${{ github.event.pull_request.head.repo.full_name }}" >> $GITHUB_ENV
          echo "PR_HEAD_OWNER=${{ github.event.pull_request.head.repo.owner.login }}" >> $GITHUB_ENV
          echo "PR_HEAD_REPO=${{ github.event.pull_request.head.repo.name }}" >> $GITHUB_ENV
          echo "PR_HEAD_SHA=${{ github.event.pull_request.head.sha }}" >> $GITHUB_ENV

      - name: Install requirements (sf CLI, sfdx-git-delta, jq, gh)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq git curl ca-certificates
          npm i -g @salesforce/cli@latest
          echo y | sf plugins install sfdx-git-delta || true
          if ! command -v gh >/dev/null 2>&1; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
              | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
              && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
              && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
              | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
              && sudo apt update && sudo apt install -y gh
          fi

      - name: Ensure Java 11+
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'zulu'

      - name: Fetch origin/main and prepare refs
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          git fetch --no-tags origin main:refs/remotes/origin/main
          git rev-parse --verify origin/main
          echo "PR #${PR_NUMBER}: head=${PR_HEAD_REF} repo=${PR_HEAD_REPO_FULL} sha=${PR_HEAD_SHA}"

      - name: Fetch feature branch (supports forks)
        id: fetch_feature
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          OWNER="${PR_HEAD_OWNER}"
          REPONAME="${PR_HEAD_REPO}"
          BRANCH="${PR_HEAD_REF}"
          PR_NUM="${PR_NUMBER}"
          echo "Fetching '${BRANCH}' from ${OWNER}/${REPONAME} ..."

          if [ "${OWNER}/${REPONAME}" = "${{ github.repository }}" ]; then
            if ! git fetch origin "refs/heads/${BRANCH}:refs/remotes/pr/${BRANCH}"; then
              echo "Direct fetch failed; trying PR ref fallback..."
              git fetch origin "refs/pull/${PR_NUM}/head:refs/remotes/pr/${BRANCH}"
            fi
          else
            git remote remove fork 2>/dev/null || true
            git remote add fork "https://x-access-token:${GH_TOKEN}@github.com/${OWNER}/${REPONAME}.git"
            if ! git fetch --no-tags fork "refs/heads/${BRANCH}:refs/remotes/pr/${BRANCH}"; then
              echo "Fork fetch failed; trying PR ref fallback..."
              git fetch origin "refs/pull/${PR_NUM}/head:refs/remotes/pr/${BRANCH}"
            fi
          fi

          if git show-ref --verify --quiet "refs/remotes/pr/${BRANCH}"; then
            echo "FETCH_REF=refs/remotes/pr/${BRANCH}" >> $GITHUB_ENV
          else
            echo "Could not fetch branch by name; falling back to PR head SHA ${PR_HEAD_SHA}"
            echo "FETCH_REF=${PR_HEAD_SHA}" >> $GITHUB_ENV
          fi

      - name: Generate metadata delta (origin/main -> feature branch)
        id: gen_delta
        run: |
          set -euo pipefail
          TO_REF="${FETCH_REF}"
          echo "Generating delta: origin/main -> ${TO_REF}"
          mkdir -p changed-sources
          sf sgd source delta \
            --from "origin/main" \
            --to "${TO_REF}" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app/"

          if [ -d changed-sources/force-app ] && [ -n "$(ls -A changed-sources/force-app || true)" ]; then
            find changed-sources/force-app -type f | sed 's#^changed-sources/##' > changed-files.txt
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Abort if no metadata changes
        if: steps.gen_delta.outputs.no_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          BODY="No deployable metadata detected between \`main\` and feature branch \`${PR_HEAD_REF}\` (PR #${PR_NUMBER}). Nothing to promote."
          echo "$BODY"
          gh pr comment "${PR_NUMBER}" --body "$BODY" || true
          exit 0

      - name: Conflict check vs main (merge-base & delta intersection)
        id: conflict_check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          FEATURE_REF="${FETCH_REF}"
          MERGE_BASE=$(git merge-base origin/main "${FEATURE_REF}")
          echo "merge-base: ${MERGE_BASE}"

          git diff --name-only "${MERGE_BASE}" origin/main > files_changed_on_main_since_base.txt

          conflicts=false
          if [ -s changed-files.txt ] && [ -s files_changed_on_main_since_base.txt ]; then
            if grep -xF -f changed-files.txt files_changed_on_main_since_base.txt >/dev/null 2>&1; then
              conflicts=true
            fi
          fi

          if [ "${conflicts}" = "true" ]; then
            BODY="⛔ *Promotion blocked*: Files changed on \`main\` since this branch diverged also appear in the feature delta. Please rebase/merge main into the feature and retry.\n\nOverlap:\n"
            grep -xF -f changed-files.txt files_changed_on_main_since_base.txt | sed -e 's/^/- `/' -e 's/$/`/' >> /tmp/conflict_list.txt || true
            [ -s /tmp/conflict_list.txt ] && BODY="${BODY}$(cat /tmp/conflict_list.txt)\n"
            echo "$BODY"
            gh pr comment "${PR_NUMBER}" --body "$BODY" || true
            exit 1
          else
            echo "No conflicting changes on main detected."
          fi

      - name: Create release branch from origin/main
        id: create_branch
        run: |
          set -euo pipefail
          SHORTSHA=$(echo "${PR_HEAD_SHA}" | cut -c1-7)
          RELEASE_BRANCH="release/pr-${PR_NUMBER}-${SHORTSHA}"
          git checkout -b "${RELEASE_BRANCH}" origin/main
          echo "RELEASE_BRANCH=${RELEASE_BRANCH}" >> $GITHUB_ENV
          echo "release_branch=${RELEASE_BRANCH}" >> $GITHUB_OUTPUT

      - name: Copy delta into release branch and commit
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git config --global user.email "augusto@zaelot.com"
          git config --global user.name "Augusto Presotto"
          rsync -av --delete changed-sources/force-app/ force-app/
          git add -A force-app/
          if git diff --cached --quiet; then
            MSG="Release creation aborted: no changes to commit on release branch for PR #${PR_NUMBER}."
            echo "$MSG"
            gh pr comment "${PR_NUMBER}" --body "$MSG" || true
            exit 0
          fi
          git commit -m "release: promote PR #${PR_NUMBER} (${PR_HEAD_REF} -> main) [automated]"
          git push origin "HEAD:${RELEASE_BRANCH}"

      - name: Open PR from release branch into main
        id: open_pr
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = process.env.RELEASE_BRANCH;
            const base = "main";
            const title = `[release] Promote PR #${process.env.PR_NUMBER} -> main: ${process.env.PR_TITLE}`;
            const body = `Automated release PR to promote feature from staging PR #${process.env.PR_NUMBER}.\n\nFeature branch: \`${process.env.PR_HEAD_REF}\`\nFeature head SHA: \`${process.env.PR_HEAD_SHA}\`\n\nThis PR contains only the metadata delta between \`origin/main\` and the feature branch.`;
            const pr = await github.rest.pulls.create({ owner, repo, title, head, base, body, maintainer_can_modify: true });
            core.info(`Created release PR #${pr.data.number}`);
            core.setOutput('release_pr_number', pr.data.number.toString());
            core.setOutput('release_pr_url', pr.data.html_url);

      - name: Comment original staging PR about release PR
        if: always()
        run: |
          RELEASE_PR_NUMBER=${{ steps.open_pr.outputs.release_pr_number }}
          RELEASE_PR_URL=${{ steps.open_pr.outputs.release_pr_url }}
          BODY="✅ Automated release PR created: #${RELEASE_PR_NUMBER} (${RELEASE_PR_URL}). This PR contains only the metadata changes from the feature branch and will be validated against Production (check-only)."
          echo "$BODY"
          if command -v gh >/dev/null 2>&1; then
            gh pr comment "${PR_NUMBER}" --body "$BODY" || true
          fi

      - name: Authenticate to Production (JWT) — write key file
        if: always()
        env:
          SF_JWT_KEY_PROD: ${{ secrets.SF_JWT_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${SF_JWT_KEY_PROD:-}" ]; then
            echo "SF_JWT_KEY_PROD not set; skipping prod validation"
            exit 78
          fi
          umask 177
          printf "%s" "$SF_JWT_KEY_PROD" > jwt_prod.key
          echo "Wrote jwt_prod.key (umask 177)."

      - name: Login to Production (JWT)
        if: always()
        env:
          SF_JWT_CLIENT_PROD: ${{ secrets.SF_JWT_CLIENT }}
          SF_JWT_USERNAME_PROD: ${{ secrets.SF_JWT_USERNAME }}
          SF_LOGIN_URL_PROD: ${{ env.SF_LOGIN_URL_PROD }}
        run: |
          set -euo pipefail
          if [ -z "${SF_JWT_CLIENT_PROD:-}" ] || [ -z "${SF_JWT_USERNAME_PROD:-}" ]; then
            echo "SF_JWT_CLIENT_PROD or SF_JWT_USERNAME_PROD not set; skipping prod validation"
            exit 78
          fi
          sf org login jwt \
            --username "$SF_JWT_USERNAME_PROD" \
            --client-id "$SF_JWT_CLIENT_PROD" \
            --jwt-key-file jwt_prod.key \
            --instance-url "${SF_LOGIN_URL_PROD}" \
            --alias ProdForValidation --set-default --json

      - name: Validate-only deploy to Production (check-only) and persist JSON
        if: always()
        run: |
          set -euo pipefail
          if [ ! -d changed-sources/force-app ]; then
            echo "No changed-sources present to validate; skipping prod validation."
            exit 78
          fi
          sf project deploy start \
            --source-dir "changed-sources/force-app" \
            --target-org ProdForValidation \
            --dry-run \
            --test-level RunLocalTests \
            --wait 120 \
            --json > prod-validate.json || true
          echo "Wrote prod-validate.json (may contain failure details)."

      - name: Upload prod validation JSON artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: prod-validate-json-pr-${{ env.PR_NUMBER }}
          path: prod-validate.json

      - name: Summarize validation and post to release PR (best-effort)
        if: always()
        uses: actions/github-script@v7
        env:
          RELEASE_PR_NUMBER: ${{ steps.open_pr.outputs.release_pr_number }}
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner, repo = context.repo.repo;
            const prNum = parseInt(process.env.PR_NUMBER,10);
            let releasePrNum = 0;
            if (process.env.RELEASE_PR_NUMBER) {
              releasePrNum = parseInt(process.env.RELEASE_PR_NUMBER, 10) || 0;
            }
            let body = `### Production validation result for release PR #${releasePrNum || 'TBD'} (origin: PR #${prNum})\n\n`;
            const file = 'prod-validate.json';
            if (fs.existsSync(file)) {
              try {
                const data = JSON.parse(fs.readFileSync(file,'utf8'));
                const failures = (((data || {}).result || {}).details || {}).runTestResult?.failures || [];
                const deployStatus = data?.status || (data?.result?.status) || 'unknown';
                body += `Validation status: **${deployStatus}**\n\n`;
                if (failures && failures.length) {
                  body += `Found **${failures.length}** failing Apex test(s):\n\n| Class | Method | Message |\n|---|---|---|\n`;
                  for (const f of failures.slice(0,30)) {
                    const msg = String(f.message || '').replace(/\n/g, ' ').slice(0,500);
                    body += `| ${f.name} | ${f.methodName} | ${msg} |\n`;
                  }
                  body += `\n(Full validation JSON uploaded as artifact)\n`;
                } else {
                  body += "No Apex test failures found in the check-only validation.\n";
                }
              } catch (e) {
                body += `Could not parse prod-validate.json: ${e.message}\n`;
              }
            } else {
              body += "No prod-validate.json produced (validation skipped or failed before runtime).\n";
            }
            const postTo = releasePrNum || prNum;
            await github.rest.issues.createComment({ owner, repo, issue_number: postTo, body });

            // If validation had failures, mark the workflow as failed (so the next job can detect failure())
            if (fs.existsSync(file)) {
              const data = JSON.parse(fs.readFileSync(file,'utf8'));
              const failures = ((((data || {}).result || {}).details || {}).runTestResult?.failures) || [];
              if (failures.length) {
                core.setFailed(`Prod validation reported ${failures.length} Apex failures.`);
              }
            }

  # Last step on failure: just comment the failure, keep release PR OPEN (no closes/deletes)
  comment-failure-keep-pr-open:
    name: Comment failure (keep release PR open for manual merge)
    needs: promote-feature-branch
    if: failure()
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Rehydrate context
        run: |
          echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          echo "RELEASE_PR_NUMBER=${{ needs.promote-feature-branch.outputs.release_pr_number }}" >> $GITHUB_ENV

      - name: Install gh
        run: |
          sudo apt-get update -y
          sudo apt-get install -y gh

      - name: Comment failure on release PR (or original PR if missing)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          MSG="❌ Release automation failed. The release PR remains **open** for manual merge after fixes. See the summary comment above and the uploaded prod-validate.json artifact for details."
          if [ -n "${RELEASE_PR_NUMBER:-}" ]; then
            gh pr comment "${RELEASE_PR_NUMBER}" --body "${MSG}" || true
          else
            gh pr comment "${PR_NUMBER}" --body "${MSG}" || true
          fi
